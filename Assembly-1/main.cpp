#include <iostream>

void Test() {
	int a;
	int b;
	int c;

	a = 1000;
	b = a + 10;
	c = a + b;
}

int main() {
	Test();

	return 0;
}

/*
	어셈블리를 통해 릴리즈 모드에서의 디버깅이 가능.
	메모리 뷰를 통해 ebp, esp와 스택 프레임 내의 변수 값 변동 확인이 가능하며
	사실상 릴리즈 모드에서의 버그 발견이 더 어렵기 때문에 처음부터해당 모드로 개발을 진행할 것을 권장.

	어셈블리와 메모리를 읽을 수 있을 경우
	프로그램이 터졌을 때 덤프 파일을 통해 어느 부분에서 문제가 발생했는지 파악이 가능하기 때문에 아주 중요함

	디버그 모드에서는 안전장치로 인해 각 변수마다 앞 뒤로 4바이트의 공백이 존재함.
	이는 해당 변수의 메모리를 침범했는지 확인하기 위해 사용됨.
	검증 메커니즘으로는 디버그 모드에선 할당되는 모든 변수를 0xcc로 초기화를 하기 때문에
	해당 공간들이 0xcc가 아닌 값일 경우 침범했다고 판단함.

	물론 릴리즈에선 해당 과정이 다 빠짐

	그리고 릴리즈에선 지역 변수가 많다고 해서 프로그램의 속도가 느려지진 않음.
	디버그에서는 얘기가 다른데, 함수 내 사용되는 모든 지역변수를 0xcc로 초기화를 해줘야 하기 때문에, 지역 변수가 많다면 그만큼의 속도 저하가 있을 수 잇음.



	번외 ) 
	지역변수의 주소를 리턴하는 함수를 작성했을 때 해당 값을 참조해도 어셈블리 관점에서의 문제는 전혀 없다. 
	왜 ? 이미 프로세스의 스택은 1MB로 할당되어 있고, 다른 함수가 호출되어 해당 스택을 덮어 씌우기 전에 해당 메모리에 접근하면 이전에 사용한 값(쓰레기 값)에 접근 가능하기 때문.
	고로 지역변수의 주소를 리턴하는 함수 이후 다른 함수 호출이 존재하지 않는다면, 해당 주소를 참조했을 때 얻을 수 있는 값을 100% 이전에 사용한 값이다.

	아니라면, 예상하지 못한 변수를 얻겠죵

*/