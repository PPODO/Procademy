## 프로카데미 내용 정리

### 1. 어셈블리
   - [1. 레지스터](https://github.com/PPODO/Procademy?tab=readme-ov-file#1-%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0)
   - [2. 릴리즈와 디버그 모드](https://github.com/PPODO/Procademy?tab=readme-ov-file#2-%EB%A6%B4%EB%A6%AC%EC%A6%88%EC%99%80-%EB%94%94%EB%B2%84%EA%B7%B8-%EB%AA%A8%EB%93%9C)
   - [3. 명령어 체계](https://github.com/PPODO/Procademy?tab=readme-ov-file#3-%EB%AA%85%EB%A0%B9%EC%96%B4-%EC%B2%B4%EA%B3%84)
   - [4. 64비트 데이터 모델](https://github.com/PPODO/Procademy?tab=readme-ov-file#4-64%EB%B9%84%ED%8A%B8-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AA%A8%EB%8D%B8)
   - [5. C 기억 클래스 및 속성 수식자](https://github.com/PPODO/Procademy?tab=readme-ov-file#5-c-%EA%B8%B0%EC%96%B5-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%B0%8F-%EC%86%8D%EC%84%B1-%EC%88%98%EC%8B%9D%EC%9E%90)
   - [6. 컴퓨터의 음수 표현](https://github.com/PPODO/Procademy?tab=readme-ov-file#6-%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%98-%EC%9D%8C%EC%88%98-%ED%91%9C%ED%98%84)
   - [7. sizeof 연산자](https://github.com/PPODO/Procademy?tab=readme-ov-file#7-sizeof-%EC%97%B0%EC%82%B0%EC%9E%90)
   - [8. 전위 증감 연산자와 후위 증감 연산자에 대한 차이](https://github.com/PPODO/Procademy?tab=readme-ov-file#8-%EC%A0%84%EC%9C%84-%EC%A6%9D%EA%B0%90-%EC%97%B0%EC%82%B0%EC%9E%90%EC%99%80-%ED%9B%84%EC%9C%84-%EC%A6%9D%EA%B0%90-%EC%97%B0%EC%82%B0%EC%9E%90%EC%97%90-%EB%8C%80%ED%95%9C-%EC%B0%A8%EC%9D%B4)
   - [9. 삼항 연산자의 진실](https://github.com/PPODO/Procademy?tab=readme-ov-file#9-%EC%82%BC%ED%95%AD-%EC%97%B0%EC%82%B0%EC%9E%90%EC%9D%98-%EC%A7%84%EC%8B%A4)
   - [10. 비트 마스킹](https://github.com/PPODO/Procademy?tab=readme-ov-file#10-%EB%B9%84%ED%8A%B8-%EB%A7%88%EC%8A%A4%ED%82%B9)
   - [11. 연산자 우선 순위](https://github.com/PPODO/Procademy?tab=readme-ov-file#11-%EC%97%B0%EC%82%B0%EC%9E%90-%EC%9A%B0%EC%84%A0-%EC%88%9C%EC%9C%84)
   - [12. Switch-case 문의 비밀](https://github.com/PPODO/Procademy?tab=readme-ov-file#12-switch-case-%EB%AC%B8%EC%9D%98-%EB%B9%84%EB%B0%80)
   - [13. 무한 반복문](https://github.com/PPODO/Procademy?tab=readme-ov-file#13-%EB%AC%B4%ED%95%9C-%EB%B0%98%EB%B3%B5%EB%AC%B8)
   - [14. do-while문의 사용처](https://github.com/PPODO/Procademy?tab=readme-ov-file#14-do-while%EB%AC%B8%EC%9D%98-%EC%82%AC%EC%9A%A9%EC%B2%98)
   - [15. 함수 호출 시, 어셈블리 분석](https://github.com/PPODO/Procademy/tree/master?tab=readme-ov-file#15-%ED%95%A8%EC%88%98-%ED%98%B8%EC%B6%9C-%EC%8B%9C-%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC-%EB%B6%84%EC%84%9D)
   - [16. rand 함수 분석](https://github.com/PPODO/Procademy/tree/master?tab=readme-ov-file#16-rand-%ED%95%A8%EC%88%98-%EB%B6%84%EC%84%9D)
   - [17. 스택 프레임이 망가졌을 때의 분석 및 예방(EBP)](https://github.com/PPODO/Procademy/tree/master?tab=readme-ov-file#17-%EC%8A%A4%ED%83%9D-%ED%94%84%EB%A0%88%EC%9E%84%EC%9D%B4-%EB%A7%9D%EA%B0%80%EC%A1%8C%EC%9D%84-%EB%95%8C%EC%9D%98-%EB%B6%84%EC%84%9D-%EB%B0%8F-%EC%98%88%EB%B0%A9ebp)



---
# 1. 어셈블리 레지스터
기억해야할 중요 명령어로는 **ESP, EBP, EIP** 레지스터가 존재한다.

컴파일 환경이 **32비트**냐 **64비트냐**에 따라 **레지스터의 이름**이 바뀌며, 

64비트 환경에서는 **RSP, RBP, RIP**로 이름이 바뀐다.

**상위 버전**의 비트는 **하위 버전**을 **호환**해야하므로 **동일한 메모리 공간**에서 **사용하는 영역**만 다르게 하는 방식으로 **호환성을 유지**한다.


**ESP** 는 Stack Pointer 로 현재 스택 프레임의 최상단 메모리 위치를 가르킨다.

**EBP**는 Base Pointer로 현재 스택 프레임의 베이스(시작 위치)를 가르킨다.

**EIP**는 현재 실행중인 코드의 위치를 가르키는 포인터이다.

**32비트**에서는 **ESP와** **EBP를** 활용하여 **스택의 메모리 할당과 해제** 에 대한 **작업**을 진행한다.

**스택의 할당과 해제**는 **함수 단위**로 이루어지는데, 여기서 말하는 함수 단위란 **함수 내부**에서 사용되는 **지역변수의 총합 크기**를 의미한다.

즉 **A라는 함수 안**에서 **int 형 변수 2개를 사용한다면 해당 함수의 단위는 8바이트**가 되는 것이다.

다시 예로 해당 함수를 호출하게 되면, **우선 EBP를 스택에 Push**하게 된다.

이유는 **이전의 함수 위치로 돌아가기 위함**이다.

그 후, **ESP를 EBP의 위치**까지 올려준 다음, **함수의 크기만큼 sub 해준다,** 그러면 **해당 함수의 크기만큼의 스택 메모리를 할당**받게 된다.

**해제**를 위해선 **ESP를 다시 EBP 위치**로 옮긴 후, **EBP를 POP**해주면 **이전 함수의 위치로 돌아갈 수 있게 된다.**

# 2. 릴리즈와 디버그 모드
보통 **릴리즈 모드**는 **디버그**가 **안 된다**라는 생각을 가지기 마련인데, **이는 사실이 아니다.**

**릴리즈 모드**에서 **브레이크 포인트**나 **조사식**이 정상적으로 작동하지 않는 이유는 **최적화 컴파일 때문**이며, 이를 끌 경우 정상적으로 작동한다.

최적화 컴파일을 통해 **내가 작성한 코드가 컴파일러에 의해 수정**되기 때문에, **작성한 코드와 1:1 매치**가 되지 않고, 이 때문에 **정상적인 디버깅이 불가능** 했을 뿐이다.


또한 디버그 모드와 릴리즈 모드의 차이점으로는 **안전 장치 유무**이다.

**디버그 모드**에서는 **각 변수마다 앞 뒤로 4바이트의 공백 공간**이 존재한다. **해당 공간은 변수의 메모리를 침범했는지를 확인**하기 위해 사용되며,

**검증 메커니즘**으로는 **모든 변수**를 **0xcc로 초기화**를 하고, **해당 공간의 값이 0xcc가 아닌 값으로 판별**되었을 때, **에러**를 내보내게 된다.

물론 **릴리즈 모드**에서는 **해당 과정이 다 빠지게 된다.**

하지만 **릴리즈 모드**에서도 **최소한의 검증 메커니즘**이 존재하는데 바로 **시크릿 쿠키**이다

함수 내에서 **지역 변수를 참조하는 포인터를 사용할 시 자동으로 추가되는 안전장치**인데, 

**4바이트의 추가 공간**을 사용하며, **특정 값의 xor 연산**들을 통해 **해당 공간이 변조**되었는지 **확인**하는 **메커니즘**이다.

**같은 값은 두 번 xor** 할 경우 **원래의 값**이 나오기 때문에 가능한 메커니즘이며 이를 **시크릿 쿠키**라 부른다.


# 3. 명령어 체계
명령어 체계로는 **CISC와 RISC**가 존재한다. 우리가 **일반적**으로 사용하는 시스템은 **CISC 명령어 체계**를 따르고 있으며, 두 명령어 체계의 **차이**는 아래와 같다.

## CISC
**복합적 명령어 체계**. **가변적인 명령어 길이(1 ~ 16바이트)**

CISC는 **명령어 단위가 바이트 단위로 깔끔하게 나뉜다**.

우리가 일반적으로 사용하는 시스템에서 **채택한 명령어 방식**이며, 그에 대한 확인 방식은 디버깅을 통해 확인할 수 있다.

디버깅을 역순으로 진행하면 명령어의 해석이 달라지는 걸 볼 수 있을 것이다.

이는 바이트 코드를 단순히 잘못 해석하기 때문이며, 읽어오는 과정에서 우선적으로 해석되는 명령어가 존재한다면, 실제론 해당 명령어가 아니더라도 해당 명령어를 사용한 것으로 추론하기 때문에 크게 신경 쓸 문제는 아니다.

## RISC
동일한 크기의 명렁어 크기

**기계어가 단순하며 가볍다**. 주로 **아두이노**에서 사용되는 명령어 체계이다.

# 4. 64비트 데이터 모델
**64비트 데이터 모델**에 따른 **자료형의 크기**가 달라진다.
데이터 모델은 다음과 같다.
| 데이터 모델 | short | int | long | long long | pointer |
| --- | --- | --- | --- | --- | --- |
| LP64 | 16 | 32 | 64 | 64 | 64 |
| ILP64 | 16 | 64 | 64 | 64 | 64 |
| SILP64 | 64 | 64 | 64 | 64 | 64 |
| LLP64 | 16 | 32 | 32 | 64 | 64 |

우리가 **일반적으로 사용하는 시스템**은 *LLP64 데이터 모델*을 사용하고 있으며, 
**리눅스 운영체제**에서는 **LP64 데이터 모델**을 사용하고 있다.

# 5. C 기억 클래스 및 속성 수식자

## 기억 클래스
1. auto : **함수 내부에서만 선언**되어, **함수 내에서만 영향을 끼치는 변수**(**스택에 할당**). 일반적인 변수 선언시 **auto 키워드는 생략**된다.
2. extern : **전역 변수를 외부 파일**에서도 사용할 수 있게끔 해주는 키워드
3. register : **CPU의 레지스터에 변수를 직접 할당할 수 있도록 기대하는 키워드**. 일반적으로 그렇게 될 **가능성은 낮기**에 사용 빈도 또한 낮다.
4. static : **정적 변수 선언**. 지역 정적 변수와 전역 정적 변수가 존재.  
    **지역 정적 변수는 함수 내 데이터 영역에 존재하며, 해당 함수 내부에서만 접근 가능하다.**  
    **전역 정적 변수는 파일 내 데이터 영역에 존재하며, 해당 파일에서만 접근 가능한 전역 변수가 된다.**

## 속성 수식자
1. volatile : **최적화 컴파일을 하지 않기 위해 사용되는 키워드**. 프로젝트의 최적화 컴파일을 끄게 된다면 불필요한 키워드가 된다.  
**CPU의 캐시 메모리 없이 물리 메모리에 접근한다는 말 또한 있지만 이는 잘못된 얘기이며, 최적화 컴파일 여부에 대한 내용만 기억하면 된다.**


# 6. 컴퓨터의 음수 표현
**기본적으로 컴퓨터에는 음수라는 개념이 존재하지 않지만 해당 수를 표현하는 방식은 존재한다.**  
컴퓨터에선 모든 수를 **이진수로 저장**하지만, 사람이 이해하기 쉽게 하기 위해 **최상위 비트(MSB)를 1로 둠**으로서 **음수를 표현**하고자 정의했으며,   
그렇기에 **빼기에 대한 연산은 2의 보수를 활용한 덧셈**을 통해 값을 구하게 된다.

2의 보수는 **특정 값을 1의 보수로 비트 반전을 해준 값에 1을 더해줌**으로서 구할 수 있다.

**예로 25 - 10 에 대한 연산을 해보자.**  

**25에 대한 이진수는 0001 1001 이며, 10을 부호 없는 이진수로 표현하면 0000 1010이다.  
10에 대한 이진수를 1의 보수로 반전시킨 뒤, 1을 더해주겠다.**

**1111 0101  
0000 0001   (+  
ㅡㅡㅡㅡㅡㅡ  
1111 0110**

**위의 해당 값이 -10에 대한 2의 보수이다.  
그럼 이 값과 25를 더해보자.**

**0001 1001  
1111 0110   (+  
ㅡㅡㅡㅡㅡㅡ  
1 0000 1111**

**새로 구해진 최상위 비트를 버리고, 나머지 값을 10진수로 변환하면 15라는 값이 나오게 된다.**


**그럼 16진수 값을 음수로 표현하는 방법에 대한 예를 들어보자.  
0xc7이란 16진수를 signed char 타입으로 변환했을 때의 값을 알고 싶다고 했을 때  
우선 0xc7을 이진수로 변환해보면 1100 0111 이란 값이 나오게 된다.**

**이를 1의 보수로 비트 반전 시켜준 뒤, 1을 더해주면 된다.**

**0011 1000  
0000 0001  (+  
ㅡㅡㅡㅡㅡㅡ  
0011 1001**  


**그럼 57이라는 값이 나오게 되는데, 0xc7의 이진수를 봤을 때 음수라는 걸 알 수 있었으니 음수 부호를 붙여 -57이 정답이 된다.**


# 7. sizeof 연산자
sizeof 연산자는 **런타임**이 아닌 **컴파일 시간**에 **'치환'** 되기에 **걱정 없이** 사용해도 된다. 

# 8. 전위 증감 연산자와 후위 증감 연산자에 대한 차이
**일반적인 타입**에선 **후위 증감 연산자**가 **전위 증감 연산자**보다 **더 느리다**.  
**후위 증감 연산자**는 **변수의 사본을 저장하는 과정**이 필요하지만, **전위 증감 연산자는 변수의 사본을 따로 저장할 필요가 없기 때문**이다.  

**객체에서 연산자 오버로딩 사용 시**, **다른 결과**를 보여줄 수 있으므로 기억할 것.

# 9. 삼항 연산자의 진실
**최적화 컴파일**을 하지 않은 상태에서 **삼항 연산자는 if문보다 느린 속도**를 보인다.  
**컴파일러가 임시 변수**를 만들기 때문. 예로 최적화 컴파일을 끈 상태의 어셈블리를 보여주도록 하겠다.

![image](https://github.com/user-attachments/assets/9a6f336c-72b5-4e86-92b7-f8c03b2bb9db)  
위 예에서 [ebp-8]은 우리가 선언한 변수가 아닌, 컴파일러가 임의로 할당한 메모리 공간이다.

**즉, 아래 코드는**  
 
	int a = 0;

	a =  a == 0 ? a + 1 : a + 30;

**아래 코드와 같은 의미이다.**

	int a = 0;
	int b = 0;
 
	if (a == 0)
		b = a + 1;
	else
		b = a + 30;

	a = b;
 

# 10. 비트 마스킹
**비트 연산을 통해 트래픽 감소 및 로직의 간소화가 가능해진다.**  
가령 아래와 같이 8개의 on, off가 가능한 변수가 있다고 해보자. 그럼 일반적으로 bool 타입 변수 8개를 선언하여 작성할 것이다.

![image](https://github.com/user-attachments/assets/605f3b13-c4d5-48e1-85fe-4b410f1ceb58)

해당 로직을 변수 하나에 비트 하나씩 사용하여 조금 간소화 해보면 어떨까?

![image](https://github.com/user-attachments/assets/d929e407-cbe1-4bef-b9c4-a769d10e8875)

해당 코드는 char형 변수에 1바이트씩을 사용하여 설정값을 on, off 할 수 있게 작성된 코드이다. 어떤가 조금 더 보기 좋지 않은가?  


또한 **암호화**에 사용되는 **xor 비트 연산**이 존재하는데, 이는 **특이한 규칙**을 가지고 있다.  
**a와 b를 xor 연산 후 나온 값을 다시 a와 xor 연산 해주면 b의 값이 나온다는 것이다. 물론 반대도 가능하다.**


# 11. 연산자 우선 순위

![image](https://github.com/user-attachments/assets/94fca4c3-9ff6-41ec-a692-ce650d56e558)

# 12. Switch-case 문의 비밀
**일반적**으로 **잘 짜여진 switch-case문**의 경우 **다중 if-else 구문**보다 **더 빠른 속도**를 보여줄 수 있다.
이유는 **어셈블리단**에서 **cmp(비교)를 하는 것이 아닌, 메모리에 점프 테이블을 만들어 코드 구문을 뛰어 넘어 다니는 구조**이기 때문인데,   
말로서는 설명이 어려우니 직접 예시를 보도록 하자.

![image](https://github.com/user-attachments/assets/677a13a3-9fc2-4ca2-a4b0-5c076ed941c7)

해당 switch-case문의 어셈블리 코드를 보도록 하겠다.

![image](https://github.com/user-attachments/assets/43976cde-a809-48ae-96c4-145b2cf9c174)

어셈블리 코드를 보면 **우리가 일반적으로 생각하는 방식**과는 매우 많이 **다른 방식**으로 **작동**하는 것을 볼 수 있다.  
**컴파일러**마다 다르지만, **case의 개수가 n개 이상일 경우 위와 같이 점프 테이블**을 만들어 주는데,  
현재 사용중인 **ms2022 컴파일러**에선 **case문이 3개 이상**일 경우, 점프 테이블을 만들어준다.

그럼 일단 하나씩 분석해보자.

![image](https://github.com/user-attachments/assets/fe49237d-6f62-4eea-96bc-732741aea232)

**1. a의 값을 eax 레지스터로 옮긴다.**
**2. 레지스터 eax의 값을 [ebp-8]메모리 영역으로 옮긴다. 이때 해당 메모리 영역은 컴파일러가 임의로 할당한 공간이다.**
**3. [ebp-8]메모리 공간에 있는 값과 상수 3을 비교한다.**
**3-1. 해당 값을 비교하는 이유는 case문의 최대 값이 3이기 때문이다. 최대 값에 따라 해당 상수 값도 변한다.**
**4. 만약  [ebp-8]의 값이 3보다 클 경우 코드영역 (0x000DB1045)로 이동한다.**
**5. 아니라면 ecx 레지스터에 [ebp-8] 값을 옮겨주고,**
**6. 메모리 영역 0x000DB1045에 ecx * 4를 더한 만큼의 메모리 영역에서 값을 읽어와 해당 위치로 점프한다.**

그럼 해당 프로세스의 메모리를 직접 관찰해서 6번에서의 메모리 공간에 어떤 값이 있는지 살펴보자.

![image](https://github.com/user-attachments/assets/7a2e52eb-8e87-47b8-8b85-94c4e1021e8f)

해당 **점프 테이블의 메모리 공간**이다. **0x00DB1068부터 0x00DB1074**까지 **총 16바이트**가 사용되었으며, **각 4바이트마다 특정 값**들이 들어있다.
**해당 값과 어셈블리 코드의 명령어 메모리 주소**가 **비슷한 규격**을 가진 걸 알아챌 수 있는데, **정답이다.**  
**해당 메모리 공간 안에는 특정 명령어 메모리 주소(위치)가 저장되어 있고,**

![image](https://github.com/user-attachments/assets/56b73b1d-7475-46ec-bd0b-a7969f675ea3)

**해당 명령어를 통해 해당 주소로 뛰어넘어갈 수 있게 되는 것이다.**

그럼 예시를 들어보자. 
**해당 코드에서 a의 값이 2라고 가정하자.**  
**그럼 점프할 위치는 (2 * 4) + 0DB1068이다.**  
그럼 해당 메모리 위치의 값을 읽어보자.

**35 10 db 00이다.**  
보통 **역순**으로 읽어야 하므로, 
**00DB1035가 될 것이다.** 그럼 해당 메모리 위치로 이동해보자.

![image](https://github.com/user-attachments/assets/030baa52-4719-4bad-86cb-73b9c8b607cd)

**16진수 값을 대입하는데, 10진수로는 30이다.**


**그럼 만약 값이 순차적으로 증가하지 않고, 순서도 엉망이면 해당 코드를 어떻게 짜줄까?**

![image](https://github.com/user-attachments/assets/77c111af-a9c6-4792-bd85-2e27f236750b)

![image](https://github.com/user-attachments/assets/4f2ec689-7da8-439c-b788-6d3c28996f85)

**일반적인 if-else 문과 동일한 어셈블리 코드가 나오게 된다.**  
**그러면, 값이 순차적으로 증가하지만, 중간에 빼먹는 값이 존재한다면 어떨까?**

![image](https://github.com/user-attachments/assets/fbee0dd4-dc9e-4c06-8c0e-95ddcbd4d1e6)

![image](https://github.com/user-attachments/assets/fcdbb3c1-20e8-409f-980c-e6c473b697ab)

**어셈블리 코드**가 **조금 달라졌다**는 걸 눈치챌 수 있을 것이다.  
**중간에 빼먹는 값이 생기기 때문에**, **기존 방식의 점프 테이블은 만들지 못하고,** 
**또 다른 1바이트짜리 인덱스 테이블을 만들주는 과정 때문에 코드가 살짝 수정된 것이다.**

![image](https://github.com/user-attachments/assets/b94e7676-d0c3-42cf-b034-42cbf84ad6fa)

신경 쓰이는 건 해당 부분인데, 보면 **byte ptr** 즉, **0x000FE10B4 메모리 위치에서 1바이트짜리 값을 가져오라는 뜻**이다.  
그럼 해당 메모리를 직접 살펴보자.

![image](https://github.com/user-attachments/assets/cce4632e-425f-4f94-8ddb-2502d6ca1d2a)

**보면 대부분 7이라는 값이 도배되어 있고 중간중간 0부터 6까지의 값으로 채워져 있는 걸 볼 수 있다.**  
**총 23줄 90바이트 이상의 공간을 사용하고 있는데, 각 1바이트마다 점프 테이블의 인덱스값을 가진 배열인 것이다.**

그렇기 때문에 **맨 처음 1바이트엔 0이**, **다음 10바이트엔 1이 다음 20바이트엔 2가 채워져 있는 것**이다.  
**그럼 해당 값을 가져온 다음은 어떻게 진행될까?**

![image](https://github.com/user-attachments/assets/72f7af82-5ec1-4a30-8581-be5aa3e7edf9)

이건 기존 코드와 같다.  
**이전에 얻어온 인덱스 위치에 4를 곱하고 메모리 연산을 하면 점프테이블을 얻을 수 있게 된다.**

![image](https://github.com/user-attachments/assets/7dc441ec-5cf2-4555-91bc-a9068b61ab0b)

이제 조금 감이 잡히지 않는가?  
**중간중간 비어있는 값까지 점프테이블**로 만들게 된다면, **너무 많은 메모리 공간이 낭비가 되기에**  
**1바이트짜리 인덱스 테이블**을 만들어, **해당 테이블의 값을 토대로 점프 테이블에 접근 할 수 있게끔 설계**된 것이다.

참으로 효율적이지 않은가?

**결론은 switch-case문을 사용할 경우 모든 case의 값이 순차적으로 증가할 것,**  
**그리고 중간에 빼먹는 값이 최대한 없도록 하는 것이 성능적으로 좋다.**


# 13. 무한 반복문

우리가 일반적으로 사용하는 무한 반복문으론 for문과 while문이 있을 것이다.  
보통 while문을 많이 사용하지만, 성능적인 부분으로는 for 무한 반복문이 더 효율적이다.  
왜일까? 아래의 어셈블리 코드를 보자.

![image](https://github.com/user-attachments/assets/9d846593-bb30-49ba-b690-34b23a9d5016)

보면 **for 무한 반복문**은 **조건 검사 없이** jmp 명령어를 사용하고 있고,  
**while 무한 반복문**은 **매 반복**마다 **조건식의 값이 0이 아닌지를 판별**해야한다. 

**미세한 차이겠지만 성능 차이**가 있으며, **몇 만번의 반복문**을 돌릴 때 **의미**가 있는 **성능 차이**이다.  
사용할 일이 있을 수 있으니 기억해두는 게 좋을 것이다.


# 14. do-while문의 사용처
do-while문은 일반적으로 잘 사용되지 않는다. 하지만 몇몇 상황에서는 아주 유용한데 그 상황을 알아보도록 하자.

일단 **매크로 함수에서 자주 사용된다.**

![image](https://github.com/user-attachments/assets/4bdda9a5-c4c1-4e8e-b53f-ac723611d77f)

**매크로 함수는 함수와 동일한 규격**을 가져야하기 때문에 **세미클론이 필수적으로 붙어야 한다는 관행**이 존재한다.  
하지만 그럴경우, 위의 상황에서 에러가 나오게 된다.   
**매크로 함수 호출 이후의 세미클론의 위치가 if문에 붙기에 해당 절에서 if문이 끝나버리기 때문.**  
해당 문제를 해결하기 위해 do-while문을 사용해보자.

![image](https://github.com/user-attachments/assets/b3e49f45-951c-4835-93eb-7d48fa5c8dd5)

문제 해결이다.
**그냥 매크로 함수를 쓴다 == do-while로 감싸준다 라고 생각하자.**  
**MS에서 제공해주는 매크로 함수는 대부분 do-while문을 사용하고 있다.**


두 번째로는 **한 함수 내부에서 여러 if문을 사용할 경우이다.**  
아래의 예시를 보자.

![image](https://github.com/user-attachments/assets/b0807efa-44fb-4700-b750-6d736122f306)

서버에서는 위와 같은 코드가 자주 나올 수 있는데,   
해당 코드의 **문제점**으로는 **초기화 작업 코드가 여러번, 즉 중복**된다는 것이다.
이걸 해결하기 위해 do-while문을 사용할 수 있다.

![image](https://github.com/user-attachments/assets/3e280c29-2ae4-44fe-8b68-e65fbe61f207)

깔끔하다.

# 15. 함수 호출 시, 어셈블리 분석
**어떠한 매개변수도 받지 않고, 리턴 값이 존재하지 않는 함수를 작성할 시 우리가 분석할 어셈블리는 매우 간단하다.**  
**그냥 코드 영역의 메모리를 call 하기 때문..**  
**하지만, 매개변수와 리턴 값이 존재하는 함수의 어셈블리는 어떠할까?**

![image](https://github.com/user-attachments/assets/d383c92a-8fec-4e15-b4d6-6d9bf89fad71)

간단하게 매개변수로 들어오는 값을 바로 리턴해주는 함수를 작성해보았다. 그럼 해당 코드의 어셈블리를 보자.

![image](https://github.com/user-attachments/assets/cba89bf4-2d0c-4d6e-ba72-cb2c1371cbba)

함수를 호출하기전, **스택에 어떤 값을 push** 하고, **함수 호출 이후 esp에 4를 더해주는 코드**가 추가되었다.  
이들은 무엇일까?

**함수 호출 시, 어셈블리에선 함수의 매개변수를 call 이전에 스택에 밀어 넣는다.**  
그리고 함수 호출 이후, **esp에 4를 더해주는 명렁어는 이 push한 매개변수를 해제**하기 위한 코드이다.  
여기까진 쉽다.  

그러면 **함수의 리턴 값**은 어떻게 될까?

![image](https://github.com/user-attachments/assets/2ff59ce1-bd2d-4d4d-b002-33a1aac650e2)

**리턴 값을 eax 레지스터에 넣는 모습을 볼 수 있다.**  
**이는 호출 규약으로, 모든 함수의 리턴 값은 eax 레지스터에 넣어야만 한다.**  

그렇기에 코드를 아래와 같이 수정해보고 어셈블리를 다시 관찰해보면 

![image](https://github.com/user-attachments/assets/39ff1249-43c2-4cce-b67e-52ce71e3f07c)

![image](https://github.com/user-attachments/assets/bcaae58f-eb63-4bf4-adb4-1e1cf06d6f70)

**eax 레지스터에서 바로 변수 a에 값을 대입**하는 걸 볼 수 있다. 왜?  
**모든 함수의 리턴 값을 eax 레지스터에 넣어야 하기 때문.**

# 16. rand 함수 분석
**게임을 개발할 때 난수를 사용할 때가 분명히 존재한다.**  
그럴 때 사용할 수 있는 함수는 **C에서 기본적으로 제공해주는 rand 함수**나 **C++ STL에 포함되어 있는 새로운 방식을 사용해야 하는데,**  
이번엔 **C언어의 rand, srand 함수를 어셈블리어를 통해 분석해보는 시간**을 가져보자.


**기본적으로 C에서 제공해주는 rand 함수는 난수의 분표가 일정하지 않다.**  
**signed short. 0 ~ 32767 사이의 값을 임의**로 뽑는데, 이걸 백분율을 통해 **0 ~ 99**의 값을 뽑아내보자 한다면, **rand의 값 분포 중 마지막 두 수가 67로 끝나기 때문**에  
**0 ~ 67의 값이 68 ~ 99까지의 값보다 한 번 더 나올 가능성이 존재**하기 때문이다.  
하지만 그리 큰 의미가 있지 않기 때문에 보통 rand함수를 자주 쓰긴 하는데, 그냥 그렇다구요..  

또한 **rand 함수를 사용하기 위한 전제 조건**으로 **srand 함수를 통한 seed의 초기화**인데, 해당 이유는 **어셈블리를 통해 직접 확인**해 볼 수 있다.

![image](https://github.com/user-attachments/assets/3fac8f12-8f8d-4097-ad8d-96a615b759f8)

상당히 복잡해 보인다.. 하지만 겁먹지 말고 한 줄씩 분석해보자.

![image](https://github.com/user-attachments/assets/c9a3d9ba-32c3-4849-a702-18e65e26ff48)

**위의 두 줄은 새로운 함수가 호출되었으니, esp와 ebp의 위치를 스택 프레임에 맞추는 과정이다.**  
**나머지 명령어는 크게 신경 쓸 필요가 없다. 옛 관행을 지키기 위해 추가된 명령어들이다.(백업을 위해)**

![image](https://github.com/user-attachments/assets/b60f338c-c736-4ef7-93bd-cf51931ad5b1)

**처음 두 명령어는 크게 신경 쓸 필요 없다. 컴파일러에 따라 달라질 수 있는 명령어다.  
사실 아래에 있는 대부분의 명령어가 그렇지만, 우리의 컴파일러에선 이렇게 나왔으니 하나씩 분석하는 것이다.**

![image](https://github.com/user-attachments/assets/8e27f814-987e-4095-a132-c62863460f54)

**주목할 건 FlsGetValue 함수 호출이다.  
해당 함수에 대한 자세한 설명은 찾아볼 수 없지만, 기본적으로 srand는 스레드 단위로 초기화를 해줘야 한다.  
즉 srand의 시드 값은 스레드별로 존재한다는 것.  
또한 srand의 시드 값은 ptd라는 구조체 내부에 저장을 하는데, 저 함수가 해당 구조체에서 값을 가져오는 것과 비슷한 역할을 하지 않을까 생각 중이다.**

다시 한 줄씩 분석해보면,  
**ecx 레지스터에 0x00760942E4 주소에 있는 값을 가져오고, 
ebx를 xor 연산하고, ebp - 4 위치에 존재하는 메모리 공간에 eax 레지스터의 값을 복사하고 있다.  
여기서 ebx에는 쓰레기 값이 들어가 있을 것이고, eax 레지스터에는 이전 함수의 리턴 값이 존재할 것이다.**

**그리고 ecx 레지스터를 0FFFFFFFF 와 비교한 뒤, 두 값이 같다면 특정 코드 영역으로 점프하도록 설계되어 있다.  
아마 정상적인 값을 가져오지 못 했을 경우 해당 코드 영역으로 점프할 것이다.** 

그러면 다음 코드를 살펴보자.  

![image](https://github.com/user-attachments/assets/f24aff24-4d83-4723-9338-cfd33e780e8d)

**다시 FlsGetValue 함수를 호출한다.
eax 레지스터의 값을 edi로 옮겨준다.(이전 함수의 리턴 값)  
그리고 두 값을 test연산 해준다.  
여기서 값은 레지스터를 test 연산 해준다는 것은 해당 레지스터가 0인지 아닌지 판별하겠다는 뜻이다.  
즉, edi 값이 0이라면 특정 코드 영역으로 점프하겠다는 뜻이다.  
이 또한 정상적이 값을 가져오지 못 했을 경우 동작하는 로직이므로 넘기도록하자.**

![image](https://github.com/user-attachments/assets/027de65f-b892-4357-b6ef-ffea292e6370)

**edi 레지스터와 0FFFFFFFF와 비교한 뒤, 두 값이 같다면 특정 코드 영역 데이터로 이동한다.  
이또한 위의 정상적이지 못한 로직일 경우 작동하는 것이다.  
그리고 바로 다음 줄은 그냥 jmp 명령어가 왔다.
모든 값이 정상적인 것으로 판단되었다는 뜻이다. 해당 코드 영역 데이터엔 srand를 위한 작업이 이루어지는 내용이 존재한다.**

그럼 해당 영역을 살펴보자.

![image](https://github.com/user-attachments/assets/346912b5-0356-4422-a15c-e6f9a5a5790f)

**우선 ebp-4에 존재하는 값과 10진수 868을 곱해준 뒤, ebx 레지스터에 넣는다.  
다음으로 ebx 레지스터와 edi 레지스터를 더해준다.  
그리고 또, ebx 레지스터가 0인지 판별(test 명령어)하고, 맞다면 75FD0E83 코드 영역으로 이동한다.  
아니라면, ebp+8에서 eax 레지스터로 값을 가져온 뒤, ebx+24위치에 해당 값을 복사한다.**

우선 여기서 75FD0E83 코드 영역은

![image](https://github.com/user-attachments/assets/085bd7f6-6a53-4949-b64a-b69561774561)

abort 함수 호출 부분이다.

![image](https://github.com/user-attachments/assets/1f1cb2e1-56c2-4c3f-b30a-a1225d1982cd)

그리고 ebp+8위치에 존재하는 값을 메모리 뷰에서 한 번 관찰해보자.

![image](https://github.com/user-attachments/assets/f6b8c785-2c0c-43d5-83d9-3f67548ad565)

**16진수로 a, 10진수로는 10의 값이다. 이는 우리가 함수의 매개변수로 넘겨준 값이다.**  
**즉 함수는 매개변수 사용시, ebp + n을 통해 특정 매개변수에 접근한다.  
그러는 이유는 함수 호출 이전에 스택에 매개변수를 넣기 때문이다.**

**그러면 ebx+24에 이 값을 대입하는 이유는 무엇일까?  
이는 초반에 얘기했던 srand 시드값이 저장되는 위치이기 때문이다.  
위에서 ebx에 이상한 연산들을 했던 이유는 해당 메모리 공간에 접근하기 위해.. 어렵고 복잡하게 계산한 것이다..**  

**이렇게 seed 값이 저장되기 때문에, rand함수는 연속적이며, 어셈블리를 통해 다음 값을 예측할 수 있게 된다.  
그렇기 때문에 crt에서 제공해는 rand 함수는 암호화 되어 있지 않다고 말할 수 있다.**


그럼 rand 함수를 살펴보자. 이번엔 불필요한 코드는 넘기도록 하겠다.

![image](https://github.com/user-attachments/assets/4f2c597b-235c-4a24-9ca6-aa51d29d2047)


**ebx+24위치에 있는 값을 0x343FD와 곱한 뒤, eax 레지스터에 넣는다.  
여기서 ebx+24는 위에서 본 것과 같이 ptd 구조체 내부에 있는 seed 값이다.**  
한 번 메모리 뷰로 살펴보자.

![image](https://github.com/user-attachments/assets/115f3bf7-1034-42e2-9d03-65f173c52102)

**진짜 10이라는 값이 들어있다.**


**그리고 0x269EC3란 값을 eax에 더해준다.  
그럼 어마무시하게 큰 값이 나오게 되는데 우리의 rand 함수는 signed short 최대 크기 범위의 값의 범위를 가지기에  
해당 크기만큼 짤라줘야할 필요가 있다. 그럼 해당하는 코드를 보자.**  

![image](https://github.com/user-attachments/assets/f3fee8e9-1c31-48d9-8f81-76136f9ea4a9)

**계산된 eax 값을 다시 ptd 구조체 내부에 저장하고, 16비트만큼 오른쪽으로 쉬프트 연산을 해주는 것을 볼 수 있다.  
다음으로 0x7FFF만큼 and 연산을 해주는데, 이는 signed short의 최대값이다.  
그렇기에 해당 범위 내의 값이 나오게 되는 것이다.**

해당 함수는 이것으로 끝이다.  
**리턴은 어떻게 하냐고?**  
**함수 호출 규약으로 모든 리턴 값을 eax에 넣는다는 걸 잊지 말도록 하자.  
이미 모든 연산을 eax 레지스터에서 했기 때문에 따로 코드를 추가할 필요가 없는 것이다.**


자, 이제 분석이 끝났으니 이 srand와 rand 함수를 우리가 직접 구현해보면 어떨까?  
코드는 아래와 같다.

![image](https://github.com/user-attachments/assets/47917e0a-62b3-4cc6-9373-8ef55d4f9a2e)

![image](https://github.com/user-attachments/assets/24569fde-3147-424a-8b92-dd2aa2e2283e)

결과 또한 같다.


# 17. 스택 프레임이 망가졌을 때의 분석 및 예방(EBP)
**스택 프레임중에서 Old EBP가 망가졌을 때 발생하는 문제와 추적, 예방 방법**을 알아보도록 하자.  
일반적으로 **스택 프레임**의 **Old EBP 영역에 접근하여 임의의 값으로 변경**하고, 
함수가 종료된다면, **EBP 레지스터는 잘못된 old ebp 값을 읽어오기에 스택 프레임. 즉 스택이 망가질 수 있게 된다.**  
왜냐? **어셈블리의 모든 변수 접근은 ebp를 기준으로 하는데, 이 ebp의 위치가 잘못되면 값을 덮어씌울 수 있기 때문.**  
그 예를 아래의 사진을 통해 볼 수 있다.

![image](https://github.com/user-attachments/assets/37be3333-fb61-4b73-a210-d8e36cbf0070)

**액세스 위반 에러가 나오게 된다.**  
**Test2 함수 내부에서 old ebp에 접근하여 0이라는 값을 넣어주고 있는데, 어떻게 그게 가능한지는 코드를 보면 이해가 될 것이다.**  
함수가 호출되는 과정에서의 어셈블리는  
**call을 통해 ip 레지스터의 값이 바뀌기 때문에**, **이전의 위치로 돌아가기 위한 코드 영역 메모리 정보와, 현재 ebp를 복원시키기 위한 값을 우선적으로 스택에 push한다.**  
**즉, 함수가 호출되어 지역변수들이 할당되기 전에, 해당 작업들이 미리 이루어지기에**  

**Old EBP
Old EIP**

**순으로 스택에 쌓이게 되는 것이다.**  
다음으로, **a와 p라는 변수가 스택에 쌓이고, p는 포인터이기 때문에 시크릿쿠키가 임의로 할당될 것이다.**

![image](https://github.com/user-attachments/assets/1f4aeb65-f764-4749-a47f-822f622012fd)

그렇기에 **어셈블리를 보면 12바이트를 할당**하는 것을 볼 수 있다.  
**시크릿쿠키는 ebp-4 위치에*  
**변수 a는 ebp-8 위치에**  
**포인터 변수 p는 ebp-12 위치에 할당되었다.**

**old ebp에 접근하기 위해선 포인터 변수를 사용할 수 밖에 없는데, 현재 포인터 변수 p는 a의 주소를 가지고 있으므로,**  
**8바이트 뒤에는 old ebp가 존재**하게 된다.(a가 ebp 기준으로 -8 위치에 있기 때문)  

**해당 값을 0으로 만들어줬기 때문에, 함수가 끝나고 ret 하는 과정에서 esp와 ebp가 이전의 값으로 복구되고,  
old ebp의 값은 0이기 때문에, ebp 레지스터는 메모리 영역 0 위치로 이동하게 된다.  
그 후, 다시 Test1에서 Test2 함수를 호출한 뒤 이루어지는 명령을 수행하게 되는데,
메모리 영역 0은 할당되지 않은 공간이기에, 액세스 위반 에러가 나오게 되는 것이다.**  

**실무에서는 현 예제와 같은 상황이 나오기 쉽지 않다. ebp의 값이 무조건 0이 될 수 없기 때문에 분석하기 힘들겠지만,**  
일단 우리는 연습이기 그런 상황을 만들고 분석, 추척, 예방을 해보도록 하자.


**일단, 평벙한 지역변수를 사용할 때 액세스 위반 에러가 나오진 않는다.**  
**만약 나왔다면 그건 십중팔구 ebp or esp에 문제가 있다는 것인데,** 
일단 무엇이 문제인지부터 확정지어보자.

**ebp와 esp의 값이 잘못되었는지 판별하려면 어떻게 해야할까?**  
**그렇다. 바로 메모리뷰를 보는 것이다.**

![image](https://github.com/user-attachments/assets/61df27b3-f1a7-4501-b072-63cbf92ebd6b)

하지만 현재 ebp의 위치는 0이기 때문에 값이 저렇게 나올 것이다. 그럼 어떻게 해야할까?

**일반적으로 이런 오류가 났을 때 esp는 변경되기 쉽지 않기 때문에, 우리는 esp의 값이 정상적일 것이라는 믿음을 가지고**  
**esp를 먼저 봐야한다.**

![image](https://github.com/user-attachments/assets/dfcbe631-4fcf-454e-89e5-8e8cb5e0591d)

**이것이 esp가 현재 위치한 스택 프레임의 구조이다.**  
**이미 test2 함수는 리턴되었고, 이전의 위치로 복귀했기 때문에 test1의 스택 프레임의 모습을 볼 수 있다.**  
그렇다면 우린 어떻게 해야할까?

**현 스택 프레임의 바로 위는 이전에 호출된 함수의 스택프레임이다. 아직 메모리가 남아있으므로 우리가 분석할 수 있을 것이다.**

![image](https://github.com/user-attachments/assets/1ff629fd-baa9-4709-b76c-72450afb5271)

**이것이 메모리에 남아있는 이전 함수 호출의 스택 프레임이다.**  
**아래부터 천천히 돌아갈 코드 위치, old ebp, 시크릿 쿠키, 변수 a, 포인터 변수 p이다.**  

**잘 보면 old ebp의 값이 이상하다는 걸 확인할 수 있을 것이다.  
그럼 문제를 확정지을 수 있다. old ebp가 잘못 된 값이기에  
함수가 ret 한 후 문제가 발생한 것이다.**

어떤 함수에서 문제가 발생했고, 어느 부분에서 문제가 발생했는지 추적과 분석을 완료했다.  
**그러면 예방은 어떻게 해야할까?**  
**아쉽게도 예방은 디버깅이 가능한 코드를 심어놓고 다시 해당 문제가 발생할 때까지 기다리는 수 말곤 없다.**  
코드는 아래와 같다.  

![image](https://github.com/user-attachments/assets/9f73e51f-cf8a-45ff-8e3a-0a4c1fd2cc05)

**함수 내부 커다란 로직 하나씩 ebp를 검사하는 조건식을 넣고, 문제가 발생하면 브레이크를 거는 방식이다.  
해당 코드로 더 좁은 범위. 즉 어떤 특정 로직에서 문제가 발생하는지 추적이 가능하다.**  
이해가 됐는가? 


**그럼 만약 EIP가 망가져 돌아갈 주소가 잘못된다면 어떻게 될까?**

![image](https://github.com/user-attachments/assets/61d5089c-7371-404e-873b-33a02514a2e8)

![image](https://github.com/user-attachments/assets/fe6061f9-8ceb-4577-9cb2-323e3464e7a6)

**지금 우리는 eip가 돌아갈 주소에 0을 대입했기에 이런 직관적인 에러 창을 볼 수 있지만, 실무에선 다를 수 있다.   
만약에 이와같이 말도 안 되는 위치로 코드가 점프한다면 eip가 잘못되었음을 알 수 있을 것이다.**

**일단 이런 상황에선 콜 스택또한 깨지기 때문에, 어느 함수에서 문제가 발생했는지 바로 파악할 수 없게 된다.**  
그럼 그 방법을 알아보도록 하자.

**eip는 잘못되었지만, ebp는 살아있을 것이다. 메모리뷰에 검색해보자.
왜냐하면 코드의 위치가 변경되는 명령어는 ret, call 이기 때문이다. 
앵간해선 ret 뒤에 ip 주소가 잘못되어 문제가 생길 확률이 높기에, ebp는 복원되어 있을 것이다.**

![image](https://github.com/user-attachments/assets/ff00f17b-2ec3-4fa9-9ae3-b8ed9a7e1c8d)

**이것이 현재 old ebp와 돌아갈 ip 주소이다.**  
그럼 여기서 돌아갈 ip 주소로 들어가보자.

![image](https://github.com/user-attachments/assets/dffb891b-f9a2-4d49-9e89-ca337a22c18b)

**가장 마지막 줄이 돌아갔었어야할 위치이다. 그 전에는 함수 호출이 있었다.  
하지만 test2에서는 어떠한 문제가 발생하지 않았다.  
즉 이는, 문제를 일으킨 함수의 이전 함수를 추적한 것이다. 왜냐?  
실제 문제를 발생시킨 문제는 ip 주소가 지워져있기에 그 전에 어떤 함수가 호출되었는지만 확인이 가능하기 때문이다.**

**나머지는 ebp 에러 추적 방법에서 설명한 방법을 응용하면 된다.**








