## 프로카데미 내용 정리

### 1. 어셈블리
   - [1. 레지스터](https://github.com/PPODO/Procademy?tab=readme-ov-file#1-%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0)
   - [2. 릴리즈와 디버그 모드](https://github.com/PPODO/Procademy?tab=readme-ov-file#2-%EB%A6%B4%EB%A6%AC%EC%A6%88%EC%99%80-%EB%94%94%EB%B2%84%EA%B7%B8-%EB%AA%A8%EB%93%9C)
   - [3. 명령어 체계](https://github.com/PPODO/Procademy?tab=readme-ov-file#3-%EB%AA%85%EB%A0%B9%EC%96%B4-%EC%B2%B4%EA%B3%84)
   - [4. 64비트 데이터 모델](https://github.com/PPODO/Procademy?tab=readme-ov-file#4-64%EB%B9%84%ED%8A%B8-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AA%A8%EB%8D%B8)
   - [5. C 기억 클래스 및 속성 수식자](https://github.com/PPODO/Procademy?tab=readme-ov-file#5-c-%EA%B8%B0%EC%96%B5-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%B0%8F-%EC%86%8D%EC%84%B1-%EC%88%98%EC%8B%9D%EC%9E%90)
   - [6. 컴퓨터의 음수 표현](https://github.com/PPODO/Procademy?tab=readme-ov-file#6-%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%98-%EC%9D%8C%EC%88%98-%ED%91%9C%ED%98%84)
   - [7. sizeof 연산자](https://github.com/PPODO/Procademy?tab=readme-ov-file#7-sizeof-%EC%97%B0%EC%82%B0%EC%9E%90)
   - [8. 전위 증감 연산자와 후위 증감 연산자에 대한 차이](https://github.com/PPODO/Procademy?tab=readme-ov-file#8-%EC%A0%84%EC%9C%84-%EC%A6%9D%EA%B0%90-%EC%97%B0%EC%82%B0%EC%9E%90%EC%99%80-%ED%9B%84%EC%9C%84-%EC%A6%9D%EA%B0%90-%EC%97%B0%EC%82%B0%EC%9E%90%EC%97%90-%EB%8C%80%ED%95%9C-%EC%B0%A8%EC%9D%B4)
   - [9. 삼항 연산자의 진실](https://github.com/PPODO/Procademy?tab=readme-ov-file#9-%EC%82%BC%ED%95%AD-%EC%97%B0%EC%82%B0%EC%9E%90%EC%9D%98-%EC%A7%84%EC%8B%A4)
   - [10. 비트 마스킹](https://github.com/PPODO/Procademy?tab=readme-ov-file#10-%EB%B9%84%ED%8A%B8-%EB%A7%88%EC%8A%A4%ED%82%B9)
   - [11. 연산자 우선 순위](https://github.com/PPODO/Procademy?tab=readme-ov-file#11-%EC%97%B0%EC%82%B0%EC%9E%90-%EC%9A%B0%EC%84%A0-%EC%88%9C%EC%9C%84)
   - [12. Switch-case 문의 비밀](https://github.com/PPODO/Procademy?tab=readme-ov-file#12-switch-case-%EB%AC%B8%EC%9D%98-%EB%B9%84%EB%B0%80)
   - [13. 무한 반복문](https://github.com/PPODO/Procademy?tab=readme-ov-file#13-%EB%AC%B4%ED%95%9C-%EB%B0%98%EB%B3%B5%EB%AC%B8)
   - [14. do-while문의 사용처](https://github.com/PPODO/Procademy?tab=readme-ov-file#14-do-while%EB%AC%B8%EC%9D%98-%EC%82%AC%EC%9A%A9%EC%B2%98)
   - [15. 함수 호출 시, 어셈블리 분석](https://github.com/PPODO/Procademy/tree/master?tab=readme-ov-file#15-%ED%95%A8%EC%88%98-%ED%98%B8%EC%B6%9C-%EC%8B%9C-%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC-%EB%B6%84%EC%84%9D)
   - [16. rand 함수 분석](https://github.com/PPODO/Procademy/tree/master?tab=readme-ov-file#16-rand-%ED%95%A8%EC%88%98-%EB%B6%84%EC%84%9D)
   - [17. 함수 호출 규약](https://github.com/PPODO/Procademy/tree/master?tab=readme-ov-file#17-%ED%95%A8%EC%88%98-%ED%98%B8%EC%B6%9C-%EA%B7%9C%EC%95%BD)
   - [18. 스택 프레임 및 EIP가 망가졌을 때의 분석 및 예방](https://github.com/PPODO/Procademy/tree/master?tab=readme-ov-file#18-%EC%8A%A4%ED%83%9D-%ED%94%84%EB%A0%88%EC%9E%84-%EB%B0%8F-eip%EA%B0%80-%EB%A7%9D%EA%B0%80%EC%A1%8C%EC%9D%84-%EB%95%8C%EC%9D%98-%EB%B6%84%EC%84%9D-%EB%B0%8F-%EC%98%88%EB%B0%A9)
   - [19. 구조체를 함수의 매개변수로 넣을 경우 벌어지는 일]
   - [20. 구조체를 함수의 리턴으로 넣을 경우 벌어지는 일]
   - [21. 함수내 지역 정적 변수의 비밀]



---
# 1. 어셈블리 레지스터
기억해야할 중요 명령어로는 **ESP, EBP, EIP** 레지스터가 존재한다.

컴파일 환경이 **32비트**냐 **64비트냐**에 따라 **레지스터의 이름**이 바뀌며, 

64비트 환경에서는 **RSP, RBP, RIP**로 이름이 바뀐다.

**상위 버전**의 비트는 **하위 버전**을 **호환**해야하므로 **동일한 메모리 공간**에서 **사용하는 영역**만 다르게 하는 방식으로 **호환성을 유지**한다.


**ESP** 는 Stack Pointer 로 현재 스택 프레임의 최상단 메모리 위치를 가르킨다.

**EBP**는 Base Pointer로 현재 스택 프레임의 베이스(시작 위치)를 가르킨다.

**EIP**는 현재 실행중인 코드의 위치를 가르키는 포인터이다.

**32비트**에서는 **ESP와** **EBP를** 활용하여 **스택의 메모리 할당과 해제** 에 대한 **작업**을 진행한다.

**스택의 할당과 해제**는 **함수 단위**로 이루어지는데, 여기서 말하는 함수 단위란 **함수 내부**에서 사용되는 **지역변수의 총합 크기**를 의미한다.

즉 **A라는 함수 안**에서 **int 형 변수 2개를 사용한다면 해당 함수의 단위는 8바이트**가 되는 것이다.

다시 예로 해당 함수를 호출하게 되면, **우선 EBP를 스택에 Push**하게 된다.

이유는 **이전의 함수 위치로 돌아가기 위함**이다.

그 후, **ESP를 EBP의 위치**까지 올려준 다음, **함수의 크기만큼 sub 해준다,** 그러면 **해당 함수의 크기만큼의 스택 메모리를 할당**받게 된다.

**해제**를 위해선 **ESP를 다시 EBP 위치**로 옮긴 후, **EBP를 POP**해주면 **이전 함수의 위치로 돌아갈 수 있게 된다.**

# 2. 릴리즈와 디버그 모드
보통 **릴리즈 모드**는 **디버그**가 **안 된다**라는 생각을 가지기 마련인데, **이는 사실이 아니다.**

**릴리즈 모드**에서 **브레이크 포인트**나 **조사식**이 정상적으로 작동하지 않는 이유는 **최적화 컴파일 때문**이며, 이를 끌 경우 정상적으로 작동한다.

최적화 컴파일을 통해 **내가 작성한 코드가 컴파일러에 의해 수정**되기 때문에, **작성한 코드와 1:1 매치**가 되지 않고, 이 때문에 **정상적인 디버깅이 불가능** 했을 뿐이다.


또한 디버그 모드와 릴리즈 모드의 차이점으로는 **안전 장치 유무**이다.

**디버그 모드**에서는 **각 변수마다 앞 뒤로 4바이트의 공백 공간**이 존재한다. **해당 공간은 변수의 메모리를 침범했는지를 확인**하기 위해 사용되며,

**검증 메커니즘**으로는 **모든 변수**를 **0xcc로 초기화**를 하고, **해당 공간의 값이 0xcc가 아닌 값으로 판별**되었을 때, **에러**를 내보내게 된다.

물론 **릴리즈 모드**에서는 **해당 과정이 다 빠지게 된다.**

하지만 **릴리즈 모드**에서도 **최소한의 검증 메커니즘**이 존재하는데 바로 **시크릿 쿠키**이다

함수 내에서 **지역 변수를 참조하는 포인터를 사용할 시 자동으로 추가되는 안전장치**인데, 

**4바이트의 추가 공간**을 사용하며, **특정 값의 xor 연산**들을 통해 **해당 공간이 변조**되었는지 **확인**하는 **메커니즘**이다.

**같은 값은 두 번 xor** 할 경우 **원래의 값**이 나오기 때문에 가능한 메커니즘이며 이를 **시크릿 쿠키**라 부른다.


# 3. 명령어 체계
명령어 체계로는 **CISC와 RISC**가 존재한다. 우리가 **일반적**으로 사용하는 시스템은 **CISC 명령어 체계**를 따르고 있으며, 두 명령어 체계의 **차이**는 아래와 같다.

## CISC
**복합적 명령어 체계**. **가변적인 명령어 길이(1 ~ 16바이트)**

CISC는 **명령어 단위가 바이트 단위로 깔끔하게 나뉜다**.

우리가 일반적으로 사용하는 시스템에서 **채택한 명령어 방식**이며, 그에 대한 확인 방식은 디버깅을 통해 확인할 수 있다.

디버깅을 역순으로 진행하면 명령어의 해석이 달라지는 걸 볼 수 있을 것이다.

이는 바이트 코드를 단순히 잘못 해석하기 때문이며, 읽어오는 과정에서 우선적으로 해석되는 명령어가 존재한다면, 실제론 해당 명령어가 아니더라도 해당 명령어를 사용한 것으로 추론하기 때문에 크게 신경 쓸 문제는 아니다.

## RISC
동일한 크기의 명렁어 크기

**기계어가 단순하며 가볍다**. 주로 **아두이노**에서 사용되는 명령어 체계이다.

# 4. 64비트 데이터 모델
**64비트 데이터 모델**에 따른 **자료형의 크기**가 달라진다.
데이터 모델은 다음과 같다.
| 데이터 모델 | short | int | long | long long | pointer |
| --- | --- | --- | --- | --- | --- |
| LP64 | 16 | 32 | 64 | 64 | 64 |
| ILP64 | 16 | 64 | 64 | 64 | 64 |
| SILP64 | 64 | 64 | 64 | 64 | 64 |
| LLP64 | 16 | 32 | 32 | 64 | 64 |

우리가 **일반적으로 사용하는 시스템**은 *LLP64 데이터 모델*을 사용하고 있으며, 
**리눅스 운영체제**에서는 **LP64 데이터 모델**을 사용하고 있다.

# 5. C 기억 클래스 및 속성 수식자

## 기억 클래스
1. auto : **함수 내부에서만 선언**되어, **함수 내에서만 영향을 끼치는 변수**(**스택에 할당**). 일반적인 변수 선언시 **auto 키워드는 생략**된다.
2. extern : **전역 변수를 외부 파일**에서도 사용할 수 있게끔 해주는 키워드
3. register : **CPU의 레지스터에 변수를 직접 할당할 수 있도록 기대하는 키워드**. 일반적으로 그렇게 될 **가능성은 낮기**에 사용 빈도 또한 낮다.
4. static : **정적 변수 선언**. 지역 정적 변수와 전역 정적 변수가 존재.  
    **지역 정적 변수는 함수 내 데이터 영역에 존재하며, 해당 함수 내부에서만 접근 가능하다.**  
    **전역 정적 변수는 파일 내 데이터 영역에 존재하며, 해당 파일에서만 접근 가능한 전역 변수가 된다.**

## 속성 수식자
1. volatile : **최적화 컴파일을 하지 않기 위해 사용되는 키워드**. 프로젝트의 최적화 컴파일을 끄게 된다면 불필요한 키워드가 된다.  
**CPU의 캐시 메모리 없이 물리 메모리에 접근한다는 말 또한 있지만 이는 잘못된 얘기이며, 최적화 컴파일 여부에 대한 내용만 기억하면 된다.**


# 6. 컴퓨터의 음수 표현
**기본적으로 컴퓨터에는 음수라는 개념이 존재하지 않지만 해당 수를 표현하는 방식은 존재한다.**  
컴퓨터에선 모든 수를 **이진수로 저장**하지만, 사람이 이해하기 쉽게 하기 위해 **최상위 비트(MSB)를 1로 둠**으로서 **음수를 표현**하고자 정의했으며,   
그렇기에 **빼기에 대한 연산은 2의 보수를 활용한 덧셈**을 통해 값을 구하게 된다.

2의 보수는 **특정 값을 1의 보수로 비트 반전을 해준 값에 1을 더해줌**으로서 구할 수 있다.

**예로 25 - 10 에 대한 연산을 해보자.**  

**25에 대한 이진수는 0001 1001 이며, 10을 부호 없는 이진수로 표현하면 0000 1010이다.  
10에 대한 이진수를 1의 보수로 반전시킨 뒤, 1을 더해주겠다.**

**1111 0101  
0000 0001   (+  
ㅡㅡㅡㅡㅡㅡ  
1111 0110**

**위의 해당 값이 -10에 대한 2의 보수이다.  
그럼 이 값과 25를 더해보자.**

**0001 1001  
1111 0110   (+  
ㅡㅡㅡㅡㅡㅡ  
1 0000 1111**

**새로 구해진 최상위 비트를 버리고, 나머지 값을 10진수로 변환하면 15라는 값이 나오게 된다.**


**그럼 16진수 값을 음수로 표현하는 방법에 대한 예를 들어보자.  
0xc7이란 16진수를 signed char 타입으로 변환했을 때의 값을 알고 싶다고 했을 때  
우선 0xc7을 이진수로 변환해보면 1100 0111 이란 값이 나오게 된다.**

**이를 1의 보수로 비트 반전 시켜준 뒤, 1을 더해주면 된다.**

**0011 1000  
0000 0001  (+  
ㅡㅡㅡㅡㅡㅡ  
0011 1001**  


**그럼 57이라는 값이 나오게 되는데, 0xc7의 이진수를 봤을 때 음수라는 걸 알 수 있었으니 음수 부호를 붙여 -57이 정답이 된다.**


# 7. sizeof 연산자
sizeof 연산자는 **런타임**이 아닌 **컴파일 시간**에 **'치환'** 되기에 **걱정 없이** 사용해도 된다. 

# 8. 전위 증감 연산자와 후위 증감 연산자에 대한 차이
**일반적인 타입**에선 **후위 증감 연산자**가 **전위 증감 연산자**보다 **더 느리다**.  
**후위 증감 연산자**는 **변수의 사본을 저장하는 과정**이 필요하지만, **전위 증감 연산자는 변수의 사본을 따로 저장할 필요가 없기 때문**이다.  

**객체에서 연산자 오버로딩 사용 시**, **다른 결과**를 보여줄 수 있으므로 기억할 것.

# 9. 삼항 연산자의 진실
**최적화 컴파일**을 하지 않은 상태에서 **삼항 연산자는 if문보다 느린 속도**를 보인다.  
**컴파일러가 임시 변수**를 만들기 때문. 예로 최적화 컴파일을 끈 상태의 어셈블리를 보여주도록 하겠다.

![image](https://github.com/user-attachments/assets/9a6f336c-72b5-4e86-92b7-f8c03b2bb9db)  
위 예에서 [ebp-8]은 우리가 선언한 변수가 아닌, 컴파일러가 임의로 할당한 메모리 공간이다.

**즉, 아래 코드는**  
 
	int a = 0;

	a =  a == 0 ? a + 1 : a + 30;

**아래 코드와 같은 의미이다.**

	int a = 0;
	int b = 0;
 
	if (a == 0)
		b = a + 1;
	else
		b = a + 30;

	a = b;
 

# 10. 비트 마스킹
**비트 연산을 통해 트래픽 감소 및 로직의 간소화가 가능해진다.**  
가령 아래와 같이 8개의 on, off가 가능한 변수가 있다고 해보자. 그럼 일반적으로 bool 타입 변수 8개를 선언하여 작성할 것이다.

![image](https://github.com/user-attachments/assets/605f3b13-c4d5-48e1-85fe-4b410f1ceb58)

해당 로직을 변수 하나에 비트 하나씩 사용하여 조금 간소화 해보면 어떨까?

![image](https://github.com/user-attachments/assets/d929e407-cbe1-4bef-b9c4-a769d10e8875)

해당 코드는 char형 변수에 1바이트씩을 사용하여 설정값을 on, off 할 수 있게 작성된 코드이다. 어떤가 조금 더 보기 좋지 않은가?  


또한 **암호화**에 사용되는 **xor 비트 연산**이 존재하는데, 이는 **특이한 규칙**을 가지고 있다.  
**a와 b를 xor 연산 후 나온 값을 다시 a와 xor 연산 해주면 b의 값이 나온다는 것이다. 물론 반대도 가능하다.**


# 11. 연산자 우선 순위

![image](https://github.com/user-attachments/assets/94fca4c3-9ff6-41ec-a692-ce650d56e558)

# 12. Switch-case 문의 비밀
**일반적**으로 **잘 짜여진 switch-case문**의 경우 **다중 if-else 구문**보다 **더 빠른 속도**를 보여줄 수 있다.
이유는 **어셈블리단**에서 **cmp(비교)를 하는 것이 아닌, 메모리에 점프 테이블을 만들어 코드 구문을 뛰어 넘어 다니는 구조**이기 때문인데,   
말로서는 설명이 어려우니 직접 예시를 보도록 하자.

![image](https://github.com/user-attachments/assets/677a13a3-9fc2-4ca2-a4b0-5c076ed941c7)

해당 switch-case문의 어셈블리 코드를 보도록 하겠다.

![image](https://github.com/user-attachments/assets/43976cde-a809-48ae-96c4-145b2cf9c174)

어셈블리 코드를 보면 **우리가 일반적으로 생각하는 방식**과는 매우 많이 **다른 방식**으로 **작동**하는 것을 볼 수 있다.  
**컴파일러**마다 다르지만, **case의 개수가 n개 이상일 경우 위와 같이 점프 테이블**을 만들어 주는데,  
현재 사용중인 **ms2022 컴파일러**에선 **case문이 3개 이상**일 경우, 점프 테이블을 만들어준다.

그럼 일단 하나씩 분석해보자.

![image](https://github.com/user-attachments/assets/fe49237d-6f62-4eea-96bc-732741aea232)

**1. a의 값을 eax 레지스터로 옮긴다.**
**2. 레지스터 eax의 값을 [ebp-8]메모리 영역으로 옮긴다. 이때 해당 메모리 영역은 컴파일러가 임의로 할당한 공간이다.**
**3. [ebp-8]메모리 공간에 있는 값과 상수 3을 비교한다.**
**3-1. 해당 값을 비교하는 이유는 case문의 최대 값이 3이기 때문이다. 최대 값에 따라 해당 상수 값도 변한다.**
**4. 만약  [ebp-8]의 값이 3보다 클 경우 코드영역 (0x000DB1045)로 이동한다.**
**5. 아니라면 ecx 레지스터에 [ebp-8] 값을 옮겨주고,**
**6. 메모리 영역 0x000DB1045에 ecx * 4를 더한 만큼의 메모리 영역에서 값을 읽어와 해당 위치로 점프한다.**

그럼 해당 프로세스의 메모리를 직접 관찰해서 6번에서의 메모리 공간에 어떤 값이 있는지 살펴보자.

![image](https://github.com/user-attachments/assets/7a2e52eb-8e87-47b8-8b85-94c4e1021e8f)

해당 **점프 테이블의 메모리 공간**이다. **0x00DB1068부터 0x00DB1074**까지 **총 16바이트**가 사용되었으며, **각 4바이트마다 특정 값**들이 들어있다.
**해당 값과 어셈블리 코드의 명령어 메모리 주소**가 **비슷한 규격**을 가진 걸 알아챌 수 있는데, **정답이다.**  
**해당 메모리 공간 안에는 특정 명령어 메모리 주소(위치)가 저장되어 있고,**

![image](https://github.com/user-attachments/assets/56b73b1d-7475-46ec-bd0b-a7969f675ea3)

**해당 명령어를 통해 해당 주소로 뛰어넘어갈 수 있게 되는 것이다.**

그럼 예시를 들어보자. 
**해당 코드에서 a의 값이 2라고 가정하자.**  
**그럼 점프할 위치는 (2 * 4) + 0DB1068이다.**  
그럼 해당 메모리 위치의 값을 읽어보자.

**35 10 db 00이다.**  
보통 **역순**으로 읽어야 하므로, 
**00DB1035가 될 것이다.** 그럼 해당 메모리 위치로 이동해보자.

![image](https://github.com/user-attachments/assets/030baa52-4719-4bad-86cb-73b9c8b607cd)

**16진수 값을 대입하는데, 10진수로는 30이다.**


**그럼 만약 값이 순차적으로 증가하지 않고, 순서도 엉망이면 해당 코드를 어떻게 짜줄까?**

![image](https://github.com/user-attachments/assets/77c111af-a9c6-4792-bd85-2e27f236750b)

![image](https://github.com/user-attachments/assets/4f2ec689-7da8-439c-b788-6d3c28996f85)

**일반적인 if-else 문과 동일한 어셈블리 코드가 나오게 된다.**  
**그러면, 값이 순차적으로 증가하지만, 중간에 빼먹는 값이 존재한다면 어떨까?**

![image](https://github.com/user-attachments/assets/fbee0dd4-dc9e-4c06-8c0e-95ddcbd4d1e6)

![image](https://github.com/user-attachments/assets/fcdbb3c1-20e8-409f-980c-e6c473b697ab)

**어셈블리 코드**가 **조금 달라졌다**는 걸 눈치챌 수 있을 것이다.  
**중간에 빼먹는 값이 생기기 때문에**, **기존 방식의 점프 테이블은 만들지 못하고,** 
**또 다른 1바이트짜리 인덱스 테이블을 만들주는 과정 때문에 코드가 살짝 수정된 것이다.**

![image](https://github.com/user-attachments/assets/b94e7676-d0c3-42cf-b034-42cbf84ad6fa)

신경 쓰이는 건 해당 부분인데, 보면 **byte ptr** 즉, **0x000FE10B4 메모리 위치에서 1바이트짜리 값을 가져오라는 뜻**이다.  
그럼 해당 메모리를 직접 살펴보자.

![image](https://github.com/user-attachments/assets/cce4632e-425f-4f94-8ddb-2502d6ca1d2a)

**보면 대부분 7이라는 값이 도배되어 있고 중간중간 0부터 6까지의 값으로 채워져 있는 걸 볼 수 있다.**  
**총 23줄 90바이트 이상의 공간을 사용하고 있는데, 각 1바이트마다 점프 테이블의 인덱스값을 가진 배열인 것이다.**

그렇기 때문에 **맨 처음 1바이트엔 0이**, **다음 10바이트엔 1이 다음 20바이트엔 2가 채워져 있는 것**이다.  
**그럼 해당 값을 가져온 다음은 어떻게 진행될까?**

![image](https://github.com/user-attachments/assets/72f7af82-5ec1-4a30-8581-be5aa3e7edf9)

이건 기존 코드와 같다.  
**이전에 얻어온 인덱스 위치에 4를 곱하고 메모리 연산을 하면 점프테이블을 얻을 수 있게 된다.**

![image](https://github.com/user-attachments/assets/7dc441ec-5cf2-4555-91bc-a9068b61ab0b)

이제 조금 감이 잡히지 않는가?  
**중간중간 비어있는 값까지 점프테이블**로 만들게 된다면, **너무 많은 메모리 공간이 낭비가 되기에**  
**1바이트짜리 인덱스 테이블**을 만들어, **해당 테이블의 값을 토대로 점프 테이블에 접근 할 수 있게끔 설계**된 것이다.

참으로 효율적이지 않은가?

**결론은 switch-case문을 사용할 경우 모든 case의 값이 순차적으로 증가할 것,**  
**그리고 중간에 빼먹는 값이 최대한 없도록 하는 것이 성능적으로 좋다.**


# 13. 무한 반복문

우리가 일반적으로 사용하는 무한 반복문으론 for문과 while문이 있을 것이다.  
보통 while문을 많이 사용하지만, 성능적인 부분으로는 for 무한 반복문이 더 효율적이다.  
왜일까? 아래의 어셈블리 코드를 보자.

![image](https://github.com/user-attachments/assets/9d846593-bb30-49ba-b690-34b23a9d5016)

보면 **for 무한 반복문**은 **조건 검사 없이** jmp 명령어를 사용하고 있고,  
**while 무한 반복문**은 **매 반복**마다 **조건식의 값이 0이 아닌지를 판별**해야한다. 

**미세한 차이겠지만 성능 차이**가 있으며, **몇 만번의 반복문**을 돌릴 때 **의미**가 있는 **성능 차이**이다.  
사용할 일이 있을 수 있으니 기억해두는 게 좋을 것이다.


# 14. do-while문의 사용처
do-while문은 일반적으로 잘 사용되지 않는다. 하지만 몇몇 상황에서는 아주 유용한데 그 상황을 알아보도록 하자.

일단 **매크로 함수에서 자주 사용된다.**

![image](https://github.com/user-attachments/assets/4bdda9a5-c4c1-4e8e-b53f-ac723611d77f)

**매크로 함수는 함수와 동일한 규격**을 가져야하기 때문에 **세미클론이 필수적으로 붙어야 한다는 관행**이 존재한다.  
하지만 그럴경우, 위의 상황에서 에러가 나오게 된다.   
**매크로 함수 호출 이후의 세미클론의 위치가 if문에 붙기에 해당 절에서 if문이 끝나버리기 때문.**  
해당 문제를 해결하기 위해 do-while문을 사용해보자.

![image](https://github.com/user-attachments/assets/b3e49f45-951c-4835-93eb-7d48fa5c8dd5)

문제 해결이다.
**그냥 매크로 함수를 쓴다 == do-while로 감싸준다 라고 생각하자.**  
**MS에서 제공해주는 매크로 함수는 대부분 do-while문을 사용하고 있다.**


두 번째로는 **한 함수 내부에서 여러 if문을 사용할 경우이다.**  
아래의 예시를 보자.

![image](https://github.com/user-attachments/assets/b0807efa-44fb-4700-b750-6d736122f306)

서버에서는 위와 같은 코드가 자주 나올 수 있는데,   
해당 코드의 **문제점**으로는 **초기화 작업 코드가 여러번, 즉 중복**된다는 것이다.
이걸 해결하기 위해 do-while문을 사용할 수 있다.

![image](https://github.com/user-attachments/assets/3e280c29-2ae4-44fe-8b68-e65fbe61f207)

깔끔하다.

# 15. 함수 호출 시, 어셈블리 분석
**어떠한 매개변수도 받지 않고, 리턴 값이 존재하지 않는 함수를 작성할 시 우리가 분석할 어셈블리는 매우 간단하다.**  
**그냥 코드 영역의 메모리를 call 하기 때문..**  
**하지만, 매개변수와 리턴 값이 존재하는 함수의 어셈블리는 어떠할까?**

![image](https://github.com/user-attachments/assets/d383c92a-8fec-4e15-b4d6-6d9bf89fad71)

간단하게 매개변수로 들어오는 값을 바로 리턴해주는 함수를 작성해보았다. 그럼 해당 코드의 어셈블리를 보자.

![image](https://github.com/user-attachments/assets/cba89bf4-2d0c-4d6e-ba72-cb2c1371cbba)

함수를 호출하기전, **스택에 어떤 값을 push** 하고, **함수 호출 이후 esp에 4를 더해주는 코드**가 추가되었다.  
이들은 무엇일까?

**함수 호출 시, 어셈블리에선 함수의 매개변수를 call 이전에 스택에 밀어 넣는다.**  
그리고 함수 호출 이후, **esp에 4를 더해주는 명렁어는 이 push한 매개변수를 해제**하기 위한 코드이다.  
여기까진 쉽다.  

그러면 **함수의 리턴 값**은 어떻게 될까?

![image](https://github.com/user-attachments/assets/2ff59ce1-bd2d-4d4d-b002-33a1aac650e2)

**리턴 값을 eax 레지스터에 넣는 모습을 볼 수 있다.**  
**이는 호출 규약으로, 모든 함수의 리턴 값은 eax 레지스터에 넣어야만 한다.**  

그렇기에 코드를 아래와 같이 수정해보고 어셈블리를 다시 관찰해보면 

![image](https://github.com/user-attachments/assets/39ff1249-43c2-4cce-b67e-52ce71e3f07c)

![image](https://github.com/user-attachments/assets/bcaae58f-eb63-4bf4-adb4-1e1cf06d6f70)

**eax 레지스터에서 바로 변수 a에 값을 대입**하는 걸 볼 수 있다. 왜?  
**모든 함수의 리턴 값을 eax 레지스터에 넣어야 하기 때문.**

# 16. rand 함수 분석
**게임을 개발할 때 난수를 사용할 때가 분명히 존재한다.**  
그럴 때 사용할 수 있는 함수는 **C에서 기본적으로 제공해주는 rand 함수**나 **C++ STL에 포함되어 있는 새로운 방식을 사용해야 하는데,**  
이번엔 **C언어의 rand, srand 함수를 어셈블리어를 통해 분석해보는 시간**을 가져보자.


**기본적으로 C에서 제공해주는 rand 함수는 난수의 분표가 일정하지 않다.**  
**signed short. 0 ~ 32767 사이의 값을 임의**로 뽑는데, 이걸 백분율을 통해 **0 ~ 99**의 값을 뽑아내보자 한다면, **rand의 값 분포 중 마지막 두 수가 67로 끝나기 때문**에  
**0 ~ 67의 값이 68 ~ 99까지의 값보다 한 번 더 나올 가능성이 존재**하기 때문이다.  
하지만 그리 큰 의미가 있지 않기 때문에 보통 rand함수를 자주 쓰긴 하는데, 그냥 그렇다구요..  

또한 **rand 함수를 사용하기 위한 전제 조건**으로 **srand 함수를 통한 seed의 초기화**인데, 해당 이유는 **어셈블리를 통해 직접 확인**해 볼 수 있다.

![image](https://github.com/user-attachments/assets/3fac8f12-8f8d-4097-ad8d-96a615b759f8)

상당히 복잡해 보인다.. 하지만 겁먹지 말고 한 줄씩 분석해보자.

![image](https://github.com/user-attachments/assets/c9a3d9ba-32c3-4849-a702-18e65e26ff48)

**위의 두 줄은 새로운 함수가 호출되었으니, esp와 ebp의 위치를 스택 프레임에 맞추는 과정이다.**  
**나머지 명령어는 크게 신경 쓸 필요가 없다. 옛 관행을 지키기 위해 추가된 명령어들이다.(백업을 위해)**

![image](https://github.com/user-attachments/assets/b60f338c-c736-4ef7-93bd-cf51931ad5b1)

**처음 두 명령어는 크게 신경 쓸 필요 없다. 컴파일러에 따라 달라질 수 있는 명령어다.  
사실 아래에 있는 대부분의 명령어가 그렇지만, 우리의 컴파일러에선 이렇게 나왔으니 하나씩 분석하는 것이다.**

![image](https://github.com/user-attachments/assets/8e27f814-987e-4095-a132-c62863460f54)

**주목할 건 FlsGetValue 함수 호출이다.  
해당 함수에 대한 자세한 설명은 찾아볼 수 없지만, 기본적으로 srand는 스레드 단위로 초기화를 해줘야 한다.  
즉 srand의 시드 값은 스레드별로 존재한다는 것.  
또한 srand의 시드 값은 ptd라는 구조체 내부에 저장을 하는데, 저 함수가 해당 구조체에서 값을 가져오는 것과 비슷한 역할을 하지 않을까 생각 중이다.**

다시 한 줄씩 분석해보면,  
**ecx 레지스터에 0x00760942E4 주소에 있는 값을 가져오고, 
ebx를 xor 연산하고, ebp - 4 위치에 존재하는 메모리 공간에 eax 레지스터의 값을 복사하고 있다.  
여기서 ebx에는 쓰레기 값이 들어가 있을 것이고, eax 레지스터에는 이전 함수의 리턴 값이 존재할 것이다.**

**그리고 ecx 레지스터를 0FFFFFFFF 와 비교한 뒤, 두 값이 같다면 특정 코드 영역으로 점프하도록 설계되어 있다.  
아마 정상적인 값을 가져오지 못 했을 경우 해당 코드 영역으로 점프할 것이다.** 

그러면 다음 코드를 살펴보자.  

![image](https://github.com/user-attachments/assets/f24aff24-4d83-4723-9338-cfd33e780e8d)

**다시 FlsGetValue 함수를 호출한다.
eax 레지스터의 값을 edi로 옮겨준다.(이전 함수의 리턴 값)  
그리고 두 값을 test연산 해준다.  
여기서 값은 레지스터를 test 연산 해준다는 것은 해당 레지스터가 0인지 아닌지 판별하겠다는 뜻이다.  
즉, edi 값이 0이라면 특정 코드 영역으로 점프하겠다는 뜻이다.  
이 또한 정상적이 값을 가져오지 못 했을 경우 동작하는 로직이므로 넘기도록하자.**

![image](https://github.com/user-attachments/assets/027de65f-b892-4357-b6ef-ffea292e6370)

**edi 레지스터와 0FFFFFFFF와 비교한 뒤, 두 값이 같다면 특정 코드 영역 데이터로 이동한다.  
이또한 위의 정상적이지 못한 로직일 경우 작동하는 것이다.  
그리고 바로 다음 줄은 그냥 jmp 명령어가 왔다.
모든 값이 정상적인 것으로 판단되었다는 뜻이다. 해당 코드 영역 데이터엔 srand를 위한 작업이 이루어지는 내용이 존재한다.**

그럼 해당 영역을 살펴보자.

![image](https://github.com/user-attachments/assets/346912b5-0356-4422-a15c-e6f9a5a5790f)

**우선 ebp-4에 존재하는 값과 10진수 868을 곱해준 뒤, ebx 레지스터에 넣는다.  
다음으로 ebx 레지스터와 edi 레지스터를 더해준다.  
그리고 또, ebx 레지스터가 0인지 판별(test 명령어)하고, 맞다면 75FD0E83 코드 영역으로 이동한다.  
아니라면, ebp+8에서 eax 레지스터로 값을 가져온 뒤, ebx+24위치에 해당 값을 복사한다.**

우선 여기서 75FD0E83 코드 영역은

![image](https://github.com/user-attachments/assets/085bd7f6-6a53-4949-b64a-b69561774561)

abort 함수 호출 부분이다.

![image](https://github.com/user-attachments/assets/1f1cb2e1-56c2-4c3f-b30a-a1225d1982cd)

그리고 ebp+8위치에 존재하는 값을 메모리 뷰에서 한 번 관찰해보자.

![image](https://github.com/user-attachments/assets/f6b8c785-2c0c-43d5-83d9-3f67548ad565)

**16진수로 a, 10진수로는 10의 값이다. 이는 우리가 함수의 매개변수로 넘겨준 값이다.**  
**즉 함수는 매개변수 사용시, ebp + n을 통해 특정 매개변수에 접근한다.  
그러는 이유는 함수 호출 이전에 스택에 매개변수를 넣기 때문이다.**

**그러면 ebx+24에 이 값을 대입하는 이유는 무엇일까?  
이는 초반에 얘기했던 srand 시드값이 저장되는 위치이기 때문이다.  
위에서 ebx에 이상한 연산들을 했던 이유는 해당 메모리 공간에 접근하기 위해.. 어렵고 복잡하게 계산한 것이다..**  

**이렇게 seed 값이 저장되기 때문에, rand함수는 연속적이며, 어셈블리를 통해 다음 값을 예측할 수 있게 된다.  
그렇기 때문에 crt에서 제공해는 rand 함수는 암호화 되어 있지 않다고 말할 수 있다.**


그럼 rand 함수를 살펴보자. 이번엔 불필요한 코드는 넘기도록 하겠다.

![image](https://github.com/user-attachments/assets/4f2c597b-235c-4a24-9ca6-aa51d29d2047)


**ebx+24위치에 있는 값을 0x343FD와 곱한 뒤, eax 레지스터에 넣는다.  
여기서 ebx+24는 위에서 본 것과 같이 ptd 구조체 내부에 있는 seed 값이다.**  
한 번 메모리 뷰로 살펴보자.

![image](https://github.com/user-attachments/assets/115f3bf7-1034-42e2-9d03-65f173c52102)

**진짜 10이라는 값이 들어있다.**


**그리고 0x269EC3란 값을 eax에 더해준다.  
그럼 어마무시하게 큰 값이 나오게 되는데 우리의 rand 함수는 signed short 최대 크기 범위의 값의 범위를 가지기에  
해당 크기만큼 짤라줘야할 필요가 있다. 그럼 해당하는 코드를 보자.**  

![image](https://github.com/user-attachments/assets/f3fee8e9-1c31-48d9-8f81-76136f9ea4a9)

**계산된 eax 값을 다시 ptd 구조체 내부에 저장하고, 16비트만큼 오른쪽으로 쉬프트 연산을 해주는 것을 볼 수 있다.  
다음으로 0x7FFF만큼 and 연산을 해주는데, 이는 signed short의 최대값이다.  
그렇기에 해당 범위 내의 값이 나오게 되는 것이다.**

해당 함수는 이것으로 끝이다.  
**리턴은 어떻게 하냐고?**  
**함수 호출 규약으로 모든 리턴 값을 eax에 넣는다는 걸 잊지 말도록 하자.  
이미 모든 연산을 eax 레지스터에서 했기 때문에 따로 코드를 추가할 필요가 없는 것이다.**


자, 이제 분석이 끝났으니 이 srand와 rand 함수를 우리가 직접 구현해보면 어떨까?  
코드는 아래와 같다.

![image](https://github.com/user-attachments/assets/47917e0a-62b3-4cc6-9373-8ef55d4f9a2e)

![image](https://github.com/user-attachments/assets/24569fde-3147-424a-8b92-dd2aa2e2283e)

결과 또한 같다.

# 17. 함수 호출 규약
**일반적인 함수의 파라미터 전달은 RTL(오른쪽에서 왼쪽)으로 이루어진다.**  
**하지만 이는 당연한 것이 아니며**, 함수의 **호출 규약에** 따라 다른 모습을 가질 수 있다.  
**함수 호출 규약이 존재하는 이유는 이미 만들어진 런타임 라이브러리의 파라미터 전달을 통일시키기 위함**이며,  
호출 규약에 대한 자세한 내용은 아래의 표를 보면 된다.

![image](https://github.com/user-attachments/assets/810e7e9a-6804-42f1-a5c2-b7ed20c2ab93)

**해당 표에서 레지스터 내 매개변수와 스택 위 매개변수 순서, 스택 정리 주체를 잘 보도록 하자.**  

**스택 정리 주체란?**  
**호출의 함수의 파라미터를 누가 정리할 것**인가에 대한 규약이다.  
**함수의 지역변수는 본인이 할당받고 본인이 정리**해야하기 때문에, **이에 대한 내용이 아님을 기억해두길 바란다.**  

**cdecl call과 stdcall이 주로 사용되는 호출 규약이며,**  
**cdecl call의 정리 주체는 호출자이며,  
stdcall 의 정리 주체는 피호출자이다.**

어셈블리를 통해 자세한 차이를 살펴보자.

![image](https://github.com/user-attachments/assets/1b6549b7-81ec-483f-a40c-c878ccc41c9b)

![image](https://github.com/user-attachments/assets/1af0944b-bd21-4970-aa1a-6001cbb84135)
**stdcall**  

![image](https://github.com/user-attachments/assets/4df7aa5b-ddc1-49bb-af57-4567eadb448a)
**cdecl call**


**가장 큰 차이는 ret 명령어 뒤에 들어가는 상수 유무 차이이다.**  
**stdcall은 피호출자, 즉 호출된 함수가 파라미터 매개변수에 대한 정리를 해야하기 때문에**   
**파라미터에 사용된 바이트만큼 ret 명령어에 인자를 넣어준다.**  

**다만, cdecl call에는 그런 모습을 볼 수 없는데,  
이는 함수 리턴 이후, 본래 실행되어야 할 코드에서 찾아볼 수 있다.**

![image](https://github.com/user-attachments/assets/018c606b-d11d-4f1c-9473-ab79b0c31cab)

**보면 esp를 12바이트 내리는 걸 볼 수 있다. 이는 스택 정리 주체가 호출자 본인이기에,  
함수 호출 이후 매개변수에 사용된 메모리 공간을 정리하는 것이다.**

**근데 만약 함수 선언은 stdcall인데, 정신나간 컴파일러가 cdecl call로 함수를 호출하게 된다면 어떻게 될까?**  
기본적으로 일어날 수 없는 일이지만, 만약을 가정하여 생각을 해보자.  
**stdcall은 호출된 함수가 매개변수를 정리하고, cdecl은 함수를 호출한 영역에서 매개변수가 정리된다.**  
**즉 함수에 사용된 매개변수가 12바이트일 경우,  
stdcall 12바이트, cdecl 12바이트. 총 24바이트를 내리게 되는 것이다.**  

**매개변수 정리가 두 번 일어나게 된다.**  
이럴경우 **문제가 생길수도 있고, 없을 수도 있다.**  
**왜? 스택을 정리하는 방법이 두 개이기 때문이다.**  
**첫 번째는 esp에 스택 프레임 크기만큼 값을 빼서 정리하는 방법과  
esp에 old ebp를 대입하여 정리하는 방법이 있는데,  
후자일 경우, 문제가 발생하지 않는다. old ebp의 값을 대입받기 때문에.**  
우리가 사용하는 ms 컴파일러는 후자의 방식을 채택하고 있기에 문제가 발생할 수 없다.  

또한 **cdecl call로만 만들 수 있는 함수**가 존재하는데, 바로 **가변인자가 존재하는 함수**이다.  
**왜냐하면 가변인자는 호출되는 시점마다 매개변수의 갯수가 달라지기 때문..**  
**그렇기 때문에 호출자만 해당 함수에 사용된 매개변수의 총 크기를 알 수 있다.**


**그리고, 레지스터 내 매개변수를 볼 수 있는데 이에 대한 내용은 그리 어렵지 않다.**  
**fastcall에서 파생된 기법으로 파라미터 전달 시, 새로운 메모리 공간을 할당하는 대신  
레지스터 변수를 파라미터처럼 사용하겠다는 의미이다.**  

**각 호출 규약마다 사용할 수 있는 레지스터의 갯수의 차이가 존재하는데, 해당 갯수만큼 레지스터 파라미터를 받을 수 있고,  
초과할 경우, 기존과 동일하게 스택에 메모리를 할당하게 된다.**


**또한 함수 호출 전, old ebp가 스택에 저장된다고 알고 있는데**  
**이것만으로는 정상적인 함수의 호출과 리턴이 불가능**하다.  
**왜? 함수가 종료되었을 때 돌아갈 코드 위치를 모르기 때문.**  

**그렇기 때문에 함수 호출 시, 돌아갈 코드의 주소와 old ebp를 스택에 push하게 된다.**

![image](https://github.com/user-attachments/assets/0b8874fd-9762-41f0-ba7f-7b39577cec37)
test1 함수의 스택 프레임이다.  
**맨 아래서부터 돌아갈 코드 주소, old ebp, 변수 z, 변수 x, 변수 y이다.**  
여기서 돌아갈 코드 주소를 디스어셈블리의 주소창에 입력하면,  

![image](https://github.com/user-attachments/assets/0a36edfc-b32c-45b4-875a-9199c907a5bb)

함수 호출 이후, 다음 명령어의 위치임을 알 수 있다.




# 18. 스택 프레임 및 EIP가 망가졌을 때의 분석 및 예방
**스택 프레임중에서 Old EBP가 망가졌을 때 발생하는 문제와 추적, 예방 방법**을 알아보도록 하자.  
일반적으로 **스택 프레임**의 **Old EBP 영역에 접근하여 임의의 값으로 변경**하고, 
함수가 종료된다면, **EBP 레지스터는 잘못된 old ebp 값을 읽어오기에 스택 프레임. 즉 스택이 망가질 수 있게 된다.**  
왜냐? **어셈블리의 모든 변수 접근은 ebp를 기준으로 하는데, 이 ebp의 위치가 잘못되면 값을 덮어씌울 수 있기 때문.**  
그 예를 아래의 사진을 통해 볼 수 있다.

![image](https://github.com/user-attachments/assets/37be3333-fb61-4b73-a210-d8e36cbf0070)

**액세스 위반 에러가 나오게 된다.**  
**Test2 함수 내부에서 old ebp에 접근하여 0이라는 값을 넣어주고 있는데, 어떻게 그게 가능한지는 코드를 보면 이해가 될 것이다.**  
함수가 호출되는 과정에서의 어셈블리는  
**call을 통해 ip 레지스터의 값이 바뀌기 때문에**, **이전의 위치로 돌아가기 위한 코드 영역 메모리 정보와, 현재 ebp를 복원시키기 위한 값을 우선적으로 스택에 push한다.**  
**즉, 함수가 호출되어 지역변수들이 할당되기 전에, 해당 작업들이 미리 이루어지기에**  

**Old EBP
Old EIP**

**순으로 스택에 쌓이게 되는 것이다.**  
다음으로, **a와 p라는 변수가 스택에 쌓이고, p는 포인터이기 때문에 시크릿쿠키가 임의로 할당될 것이다.**

![image](https://github.com/user-attachments/assets/1f4aeb65-f764-4749-a47f-822f622012fd)

그렇기에 **어셈블리를 보면 12바이트를 할당**하는 것을 볼 수 있다.  
**시크릿쿠키는 ebp-4 위치에*  
**변수 a는 ebp-8 위치에**  
**포인터 변수 p는 ebp-12 위치에 할당되었다.**

**old ebp에 접근하기 위해선 포인터 변수를 사용할 수 밖에 없는데, 현재 포인터 변수 p는 a의 주소를 가지고 있으므로,**  
**8바이트 뒤에는 old ebp가 존재**하게 된다.(a가 ebp 기준으로 -8 위치에 있기 때문)  

**해당 값을 0으로 만들어줬기 때문에, 함수가 끝나고 ret 하는 과정에서 esp와 ebp가 이전의 값으로 복구되고,  
old ebp의 값은 0이기 때문에, ebp 레지스터는 메모리 영역 0 위치로 이동하게 된다.  
그 후, 다시 Test1에서 Test2 함수를 호출한 뒤 이루어지는 명령을 수행하게 되는데,
메모리 영역 0은 할당되지 않은 공간이기에, 액세스 위반 에러가 나오게 되는 것이다.**  

**실무에서는 현 예제와 같은 상황이 나오기 쉽지 않다. ebp의 값이 무조건 0이 될 수 없기 때문에 분석하기 힘들겠지만,**  
일단 우리는 연습이기 그런 상황을 만들고 분석, 추척, 예방을 해보도록 하자.


**일단, 평벙한 지역변수를 사용할 때 액세스 위반 에러가 나오진 않는다.**  
**만약 나왔다면 그건 십중팔구 ebp or esp에 문제가 있다는 것인데,** 
일단 무엇이 문제인지부터 확정지어보자.

**ebp와 esp의 값이 잘못되었는지 판별하려면 어떻게 해야할까?**  
**그렇다. 바로 메모리뷰를 보는 것이다.**

![image](https://github.com/user-attachments/assets/61df27b3-f1a7-4501-b072-63cbf92ebd6b)

하지만 현재 ebp의 위치는 0이기 때문에 값이 저렇게 나올 것이다. 그럼 어떻게 해야할까?

**일반적으로 이런 오류가 났을 때 esp는 변경되기 쉽지 않기 때문에, 우리는 esp의 값이 정상적일 것이라는 믿음을 가지고**  
**esp를 먼저 봐야한다.**

![image](https://github.com/user-attachments/assets/dfcbe631-4fcf-454e-89e5-8e8cb5e0591d)

**이것이 esp가 현재 위치한 스택 프레임의 구조이다.**  
**이미 test2 함수는 리턴되었고, 이전의 위치로 복귀했기 때문에 test1의 스택 프레임의 모습을 볼 수 있다.**  
그렇다면 우린 어떻게 해야할까?

**현 스택 프레임의 바로 위는 이전에 호출된 함수의 스택프레임이다. 아직 메모리가 남아있으므로 우리가 분석할 수 있을 것이다.**

![image](https://github.com/user-attachments/assets/1ff629fd-baa9-4709-b76c-72450afb5271)

**이것이 메모리에 남아있는 이전 함수 호출의 스택 프레임이다.**  
**아래부터 천천히 돌아갈 코드 위치, old ebp, 시크릿 쿠키, 변수 a, 포인터 변수 p이다.**  

**잘 보면 old ebp의 값이 이상하다는 걸 확인할 수 있을 것이다.  
그럼 문제를 확정지을 수 있다. old ebp가 잘못 된 값이기에  
함수가 ret 한 후 문제가 발생한 것이다.**

어떤 함수에서 문제가 발생했고, 어느 부분에서 문제가 발생했는지 추적과 분석을 완료했다.  
**그러면 예방은 어떻게 해야할까?**  
**아쉽게도 예방은 디버깅이 가능한 코드를 심어놓고 다시 해당 문제가 발생할 때까지 기다리는 수 말곤 없다.**  
코드는 아래와 같다.  

![image](https://github.com/user-attachments/assets/9f73e51f-cf8a-45ff-8e3a-0a4c1fd2cc05)

**함수 내부 커다란 로직 하나씩 ebp를 검사하는 조건식을 넣고, 문제가 발생하면 브레이크를 거는 방식이다.  
해당 코드로 더 좁은 범위. 즉 어떤 특정 로직에서 문제가 발생하는지 추적이 가능하다.**  
이해가 됐는가? 


**그럼 만약 EIP가 망가져 돌아갈 주소가 잘못된다면 어떻게 될까?**

![image](https://github.com/user-attachments/assets/61d5089c-7371-404e-873b-33a02514a2e8)

![image](https://github.com/user-attachments/assets/fe6061f9-8ceb-4577-9cb2-323e3464e7a6)

**지금 우리는 eip가 돌아갈 주소에 0을 대입했기에 이런 직관적인 에러 창을 볼 수 있지만, 실무에선 다를 수 있다.   
만약에 이와같이 말도 안 되는 위치로 코드가 점프한다면 eip가 잘못되었음을 알 수 있을 것이다.**

**일단 이런 상황에선 콜 스택또한 깨지기 때문에, 어느 함수에서 문제가 발생했는지 바로 파악할 수 없게 된다.**  
그럼 그 방법을 알아보도록 하자.

**eip는 잘못되었지만, ebp는 살아있을 것이다. 메모리뷰에 검색해보자.
왜냐하면 코드의 위치가 변경되는 명령어는 ret, call 이기 때문이다. 
앵간해선 ret 뒤에 ip 주소가 잘못되어 문제가 생길 확률이 높기에, ebp는 복원되어 있을 것이다.**

![image](https://github.com/user-attachments/assets/ff00f17b-2ec3-4fa9-9ae3-b8ed9a7e1c8d)

**이것이 현재 old ebp와 돌아갈 ip 주소이다.**  
그럼 여기서 돌아갈 ip 주소로 들어가보자.

![image](https://github.com/user-attachments/assets/dffb891b-f9a2-4d49-9e89-ca337a22c18b)

**가장 마지막 줄이 돌아갔었어야할 위치이다. 그 전에는 함수 호출이 있었다.  
하지만 test2에서는 어떠한 문제가 발생하지 않았다.  
즉 이는, 문제를 일으킨 함수의 이전 함수를 추적한 것이다. 왜냐?  
실제 문제를 발생시킨 문제는 ip 주소가 지워져있기에 그 전에 어떤 함수가 호출되었는지만 확인이 가능하기 때문이다.**

**나머지는 ebp 에러 추적 방법에서 설명한 방법을 응용하면 된다.**


# 19. 구조체를 함수의 매개변수로 넣을 경우 벌어지는 일
우리는 이전 시간에 기본 타입을 함수의 매개변수로 넣을 경우 어셈블리 코드가 어떻게 작성되는지 분석한 적이 있다.  
기억이나지 않는 사람을 위해 다시 설명하자면, 함수가 호출되기 이전에 매개변수에 대한 값을 미리 스택에 push하고,  
함수를 call 하는 과정이 이루어진다. 그렇기에 함수에선 매개변수에 접근하기 위해 [ebp+n]과 같은 동작을 해야한다.  
(old ebp 이전에 매개변수가 스택에 push 되었기 때문)

(사진)

그렇다면, 만약 구조체는 어떠할까?  
일반적으로 32비트에서 범용 레지스터의 최대 읽기 쓰기 가능 바이트는 4바이트로 사용자 정의 구조체는 해당 크기를 뛰어넘는다.   
살짝 의아할 것이다. 이게 어떻게 가능한 일인가??!?   
이제 천천히 어셈블리 코드를 살펴보며 이해해보도록 하자.  

![image](https://github.com/user-attachments/assets/b11e0c8f-5a55-4970-8c47-f841b45251bf)

해당 코드의 어셈블리를 보도록 하자.

![image](https://github.com/user-attachments/assets/a830594c-643d-4fb4-b874-7878b47c1888)

어셈블리의 첫 번째 줄은 우리가 일반적으로 아는 방식대로 동작한다.  
매개변수의 크기만큼 esp를 올려주고, 해당 영역에 값을 복사하면 된다.  
그런데, 좀 이상한 코드들이 추가되었다.  
바로 ecx에 35바이트를 대입하는 명령어와 요상한 반복문들이 추가 되었다.  

이에 대한 설명은 아래와 같다.  
32비트에서 범용 레지스터의 최대 읽기 쓰기 가능한 값은 4바이트이기 때문에,  
우리는 구조체의 크기에서 4를 나눈 횟수만큼 반복하여 매개변수가 들어갈 스택의 위치에 값을 복사해야한다.  
stDATA 구조체의 사이즈는 140바이트이며, 이를 4로 나눌경우 35라는 값이 나온다.  
ecx는 반복문에서 카운트를 담당하는 레지스터이므로 35라는 값을 대입하는 것이고,  
아래들의 코드를 통해 4바이트씩 35번 반복되어 main 함수의 data 구조체 변수가 Test 함수의 매개변수 스택 영역으로 값이 복사될 것이다.

![image](https://github.com/user-attachments/assets/92417d05-40e0-4c05-ad74-5993dbad31fa)

해당 메모리 뷰는 매개변수에 할당된 140 바이트의 스택 영역이다.

![image](https://github.com/user-attachments/assets/3739a697-eefe-4702-afa7-41fcd0981ece)

그리고 해당 메모리 뷰는 main 함수의 data 변수이다.  
복사되는 걸 함 보자.  
모든 반복문이 종료된 후, 매개변수에 할당된 스택 영역에는  

![image](https://github.com/user-attachments/assets/2bae971b-2e25-4b63-ba30-984b13d12beb)

main 함수의 data 구조체 변수와 동일한 값을 가지게 된다.  


또한 Test 함수의 어셈블리를 보면, 구조체 변수에 접근할때 []를 사용하는데,  

![image](https://github.com/user-attachments/assets/37276d62-efe5-4807-b14b-9c08fdeb22b9)

구조체는 포인터 주소로서 접근이 가능하기에 []을 사용해야 한다.. 



# 20. 구조체를 함수의 리턴으로 넣을 경우 벌어지는 일
구조체를 함수의 리턴 값으로 사용할 경우는 조금 복잡해진다.  
19번의 내용에서 조금더 확장된 방식으로 동작한다.  
일단 말로선 설명이 어려우니 직접 코드를 보며 하나씩 분석해보자.  

![image](https://github.com/user-attachments/assets/40808451-1a32-46f6-bcb4-34cb28c43a0f)

우리가 분석해볼 코드는 위와 같다.  
그럼 어셈블리도 같이 보도록 하자. 

![image](https://github.com/user-attachments/assets/c40d1756-c354-4951-b175-21fc25787a27)

뭔가.. 이상한 코드가 많이 추가되었다..  
하나씩 분석해보자.  

![image](https://github.com/user-attachments/assets/a4f24731-38f7-4674-8374-6f1d2405d7b2)

일단 가장 처음 esp에 420을 빼서 스택 메모리 영역을 할당하는 것을 볼 수 있다.  
왜 420바이트일까? 그리고 왜 할까? 마치 함수에 매개변수를 넣는 것과 비슷하지 않은가?  
일단 stDATA 구조체의 크기는 140바이트이다. 140 * 3 은 420이며, 함수 호출 전, stDATA 구조체 3개가 들어갈 영역의 메모리를 할당해준다.  
하나는 Test 함수 내부에서 사용할 140바이트.  
하나는 Test 함수 내부에서 main 함수에 리턴 되기 전 잠시 임시로 복사해놓을 140바이트.  
마지막으로 main 함수에 리턴 값으로 받기 위한 140 바이트.  
총 3개의 구조체를 사용하기위해 420바이트를 할당받는 것이다.  
직접 한 줄씩 동작하는 코드를 보면 이해가 될 것이다.  

![image](https://github.com/user-attachments/assets/4e533991-252b-485a-8f66-21980e02f834)

다음으로 [ebp-420]의 주소 값을  eax 레지스터에 넣는 것을 볼 수 있을 것이다.  
그리고 스택에 push 해준다..  

일단 eax에 넣는 이유는 리턴값이 eax 레지스터를 사용하기 때문이며,  
들어가는 주소 값은 앞전에 설명한 할당한 3개의 stDATA 구조체 메모리 영역 중 하나이다..  
그러면 test 함수 내부를 보자.


![image](https://github.com/user-attachments/assets/b8c5886e-9159-4b74-a157-cd1be3fb3b1a)

보면 구조체 변수 data의 멤버변수에 접근하기 위해 각 범용 레지스터의 초기 값으로 [ebp + 8]위치의 값을 대입해주는데, 
해당 메모리 공간에는 바로 직전 eax 레지스터에 넣었던 [ebp-420] stDATA 구조체의 메모리 영역 중 하나의 공간을 가르키는 주소가 존재한다.  
메모리 뷰를 한 번 볼까?

![image](https://github.com/user-attachments/assets/523937c5-932e-4120-bbe8-40d47b662387)

위에서 순차적으로 old ebp, 돌아갈 ip 코드 주소, 이전에 넣었던 eax 레지스터가 가르키던 주소의 값이다.

여기까진 뭔가 사용 방식이 매개변수가 존재하는 함수와 동일하지 않은가?  
그렇다.  
최적화 컴파일러를 끈 상태에서 사용자 정의 구조체를 함수의 리턴 값으로 사용하면,  
컴파일러는 해당 함수를 사용자 정의 구조체를 매개변수로 받는 함수로 판단한다. 

다시 코드를 분석해보자.  

![image](https://github.com/user-attachments/assets/1c187aad-290a-4270-bc3e-e909e750a70d)

함수가 ret 될 때, [ebp + 8] 위치에 있는 주소 값을 다시 eax에 대입한다.  
리턴 값으로 사용해야하기 때문..  
다시 main 함수로 가보자.  

![image](https://github.com/user-attachments/assets/78670202-56f3-469d-8ff4-b278f28cafda)

우선 이전에 스택에 push한 eax 레지스터를 해제하기 위해 esp에 4를 더한다.  
그후 이전 챕터에서 본 반복문과 동일한 명령어들이 보이는데, edi 레지스터의 값이 다르다는 걸 볼 수 있을 것이다.  
[ebp - 280] 은 우리가 초반에 할당한 stDATA 구조체의 메모리 영역 중 하나이며,  
esi 레지스터가 eax인 것으로 보아 헤딩 위치에서 [ebp - 280] 위치로 값을 다시 복사하려는 코드라는 걸 알 수 있다.  
그럼 해당 코드가 실행된 후, 메모리 뷰를 살펴보자.  

![image](https://github.com/user-attachments/assets/64307953-db7b-47af-826b-bfa75f41ce4a)

조금 짤리긴 했는데, 총 280바이트가 동일한 값으로 세팅된 것을 볼 수 있다.  
자, 그럼 다시 어셈블리로 돌아가자.  

![image](https://github.com/user-attachments/assets/cdc6d645-2118-4577-b631-01484112941c)

다시 똑같은 반복문인데, esi 레지스터와 edi 레지스터의 값이 변경되었다.  
source는 이전의 [ebp - 280]위치이며,  
destination은 [ebp - 140]위치이다. 해당 위치는 stDATA 구조체의 메모리 영역 중 마지막으로 남은 하나의 공간이다.  
코드가 돌아간 뒤, 메모리 뷰를 보자.

![image](https://github.com/user-attachments/assets/69acef39-00c7-4386-bc0a-78b02d755148)

최적화 컴파일러를 끈 상태라 420바이트라는 큰 메모리 영역과 여러번의 값 복사 과정이 존재했다.  
이들은 컴파일러마다 다르게 진행될 수 있다는 사실을 알기 바란다.


# 21. 함수내 지역 정적 변수의 비밀
일반적으로 많이 사용될 일은 없지만 함수 내 지역 정적 변수는 초기화하는 값에 따라 완전히 다른 성능을 보여줄 수 있다.  

아래와 같은 상황을 한 번 보도록 하자.

![image](https://github.com/user-attachments/assets/2d9d81fb-ce3c-4326-9176-9ff6db23cf78)

해당 코드에서 정적 변수 g_A가 초기화되는 시점은 컴파일 타임이다.  
왜냐? 들어오는 값이 상수이기 때문.. 
고로 어셈블리를 보면 아주 간단하다.

![image](https://github.com/user-attachments/assets/b25c2c0d-acdc-4fca-b3b5-8cc1f75e027f)

진짜 별 내용이 없다.

하지만 아래와 같은 코드는 어떨까???

![image](https://github.com/user-attachments/assets/2b8f4d3c-9a74-409a-b6d9-46269b0c56dc)

정적 변수 g_A에 대입되는 값이 상수가 아니기 때문에, 컴파일 타임에 초기화되지 않는다.  
그럼 런타임에 함수가 최초로 실행되었을 때가 초기화 시점이며, 저 초기화 구문은 다시 실행되지 않아야 한다.  
이걸 어떻게 구현했을까??  
우리가 이런 코드를 C로 짠다고하면 아래와 같을 것이다.

![image](https://github.com/user-attachments/assets/f1c1de4c-6e38-418b-ba82-6ab07e2e8c6d)

그럼 어셈블리는 어떨까??

![image](https://github.com/user-attachments/assets/3b2a84fd-6367-445e-9eba-845af1b82f76)

아까 상수가 들어왔을 때보다 확실히 더 복잡한 명령어들이 많이 추가되었다..  

이와 같이 지역 정적 변수를 사용할 때, 상수가 아닌 런타임에 결졍되는 값이 초기화 값으로 오게 된다면  
성능은 상수일 경우보다 현저히 떨어지게 될 것이다.   

최고의 방법은 지역 정적 변수를 사용하지 않는 것이다.. 





