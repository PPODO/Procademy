## 프로카데미 내용 정리

### 1. 어셈블리
   - [1. 레지스터](#1.-어셈블리-레지스터)
   - [2. 릴리즈와 디버그 모드](#2.-릴리즈와-디버그-모드)
   - [3. 명령어 체계](#3.-명령어-체계)
   - [4. 64비트 데이터 모델](#4.-64비트-데이터-모델)
   - [5. 컴퓨터의 음수 표현](#5.-컴퓨터의-음수-표현)
   - [6. sizeof 연산자](#6.-sizeof-연산자)
   - [7. 전위 증감 연산자와 후위 증감 연산자에 대한 차이](#7.-전위-증감-연산자와-후위-증감-연산자에-대한-차이)
   - [8. 삼항 연산자의 진실](#8.-삼항-연산자의-진실)
   - [9. 비트 마스킹](#9.-비트-마스킹)
   - [10. 연산자 우선 순위](#10.-연산자-우선-순위)
   - [11. Switch-case 문의 비밀](#11.-Switch-cast-문의-비밀)
   - [12. 무한 반복문](#12.-무한-반복문)
   - [13. do-while문의 사용처](#13.-do-while문의-사용처)



---
# 1. 어셈블리 레지스터
기억해야할 중요 명령어로는 **ESP, EBP, EIP** 레지스터가 존재한다.

컴파일 환경이 **32비트**냐 **64비트냐**에 따라 **레지스터의 이름**이 바뀌며, 

64비트 환경에서는 **RSP, RBP, RIP**로 이름이 바뀐다.

**상위 버전**의 비트는 **하위 버전**을 **호환**해야하므로 **동일한 메모리 공간**에서 **사용하는 영역**만 다르게 하는 방식으로 **호환성을 유지**한다.


**ESP** 는 Stack Pointer 로 현재 스택 프레임의 최상단 메모리 위치를 가르킨다.

**EBP**는 Base Pointer로 현재 스택 프레임의 베이스(시작 위치)를 가르킨다.

**EIP**는 현재 실행중인 코드의 위치를 가르키는 포인터이다.

**32비트**에서는 **ESP와** **EBP를** 활용하여 **스택의 메모리 할당과 해제** 에 대한 **작업**을 진행한다.

**스택의 할당과 해제**는 **함수 단위**로 이루어지는데, 여기서 말하는 함수 단위란 **함수 내부**에서 사용되는 **지역변수의 총합 크기**를 의미한다.

즉 **A라는 함수 안**에서 **int 형 변수 2개를 사용한다면 해당 함수의 단위는 8바이트**가 되는 것이다.

다시 예로 해당 함수를 호출하게 되면, **우선 EBP를 스택에 Push**하게 된다.

이유는 **이전의 함수 위치로 돌아가기 위함**이다.

그 후, **ESP를 EBP의 위치**까지 올려준 다음, **함수의 크기만큼 sub 해준다,** 그러면 **해당 함수의 크기만큼의 스택 메모리를 할당**받게 된다.

**해제**를 위해선 **ESP를 다시 EBP 위치**로 옮긴 후, **EBP를 POP**해주면 **이전 함수의 위치로 돌아갈 수 있게 된다.**

# 2. 릴리즈와 디버그 모드
보통 **릴리즈 모드**는 **디버그**가 **안 된다**라는 생각을 가지기 마련인데, **이는 사실이 아니다.**

**릴리즈 모드**에서 **브레이크 포인트**나 **조사식**이 정상적으로 작동하지 않는 이유는 **최적화 컴파일 때문**이며, 이를 끌 경우 정상적으로 작동한다.

최적화 컴파일을 통해 **내가 작성한 코드가 컴파일러에 의해 수정**되기 때문에, **작성한 코드와 1:1 매치**가 되지 않고, 이 때문에 **정상적인 디버깅이 불가능** 했을 뿐이다.


또한 디버그 모드와 릴리즈 모드의 차이점으로는 **안전 장치 유무**이다.

**디버그 모드**에서는 **각 변수마다 앞 뒤로 4바이트의 공백 공간**이 존재한다. **해당 공간은 변수의 메모리를 침범했는지를 확인**하기 위해 사용되며,

**검증 메커니즘**으로는 **모든 변수**를 **0xcc로 초기화**를 하고, **해당 공간의 값이 0xcc가 아닌 값으로 판별**되었을 때, **에러**를 내보내게 된다.

물론 **릴리즈 모드**에서는 **해당 과정이 다 빠지게 된다.**

하지만 **릴리즈 모드**에서도 **최소한의 검증 메커니즘**이 존재하는데 바로 **시크릿 쿠키**이다

함수 내에서 **지역 변수를 참조하는 포인터를 사용할 시 자동으로 추가되는 안전장치**인데, 

**4바이트의 추가 공간**을 사용하며, **특정 값의 xor 연산**들을 통해 **해당 공간이 변조**되었는지 **확인**하는 **메커니즘**이다.

**같은 값은 두 번 xor** 할 경우 **원래의 값**이 나오기 때문에 가능한 메커니즘이며 이를 **시크릿 쿠키**라 부른다.


# 3. 명령어 체계
명령어 체계로는 **CISC와 RISC**가 존재한다. 우리가 **일반적**으로 사용하는 시스템은 **CISC 명령어 체계**를 따르고 있으며, 두 명령어 체계의 **차이**는 아래와 같다.

## CISC
**복합적 명령어 체계**. **가변적인 명령어 길이(1 ~ 16바이트)**

CISC는 **명령어 단위가 바이트 단위로 깔끔하게 나뉜다**.

우리가 일반적으로 사용하는 시스템에서 **채택한 명령어 방식**이며, 그에 대한 확인 방식은 디버깅을 통해 확인할 수 있다.

디버깅을 역순으로 진행하면 명령어의 해석이 달라지는 걸 볼 수 있을 것이다.

이는 바이트 코드를 단순히 잘못 해석하기 때문이며, 읽어오는 과정에서 우선적으로 해석되는 명령어가 존재한다면, 실제론 해당 명령어가 아니더라도 해당 명령어를 사용한 것으로 추론하기 때문에 크게 신경 쓸 문제는 아니다.

## RISC
동일한 크기의 명렁어 크기

**기계어가 단순하며 가볍다**. 주로 **아두이노**에서 사용되는 명령어 체계이다.

# 4. 64비트 데이터 모델
**64비트 데이터 모델**에 따른 **자료형의 크기**가 달라진다.
데이터 모델은 다음과 같다.
| 데이터 모델 | short | int | long | long long | pointer |
| --- | --- | --- | --- | --- | --- |
| LP64 | 16 | 32 | 64 | 64 | 64 |
| ILP64 | 16 | 64 | 64 | 64 | 64 |
| SILP64 | 64 | 64 | 64 | 64 | 64 |
| LLP64 | 16 | 32 | 32 | 64 | 64 |

우리가 **일반적으로 사용하는 시스템**은 *LLP64 데이터 모델*을 사용하고 있으며, 
**리눅스 운영체제**에서는 **LP64 데이터 모델**을 사용하고 있다.

# 4. C 기억 클래스 및 속성 수식자

## 기억 클래스
1. auto : **함수 내부에서만 선언**되어, **함수 내에서만 영향을 끼치는 변수**(**스택에 할당**). 일반적인 변수 선언시 **auto 키워드는 생략**된다.
2. extern : **전역 변수를 외부 파일**에서도 사용할 수 있게끔 해주는 키워드
3. register : **CPU의 레지스터에 변수를 직접 할당할 수 있도록 기대하는 키워드**. 일반적으로 그렇게 될 **가능성은 낮기**에 사용 빈도 또한 낮다.
4. static : **정적 변수 선언**. 지역 정적 변수와 전역 정적 변수가 존재.  
    **지역 정적 변수는 함수 내 데이터 영역에 존재하며, 해당 함수 내부에서만 접근 가능하다.**  
    **전역 정적 변수는 파일 내 데이터 영역에 존재하며, 해당 파일에서만 접근 가능한 전역 변수가 된다.**

## 속성 수식자
1. volatile : **최적화 컴파일을 하지 않기 위해 사용되는 키워드**. 프로젝트의 최적화 컴파일을 끄게 된다면 불필요한 키워드가 된다.  
**CPU의 캐시 메모리 없이 물리 메모리에 접근한다는 말 또한 있지만 이는 잘못된 얘기이며, 최적화 컴파일 여부에 대한 내용만 기억하면 된다.**


# 5. 컴퓨터의 음수 표현
**기본적으로 컴퓨터에는 음수라는 개념이 존재하지 않지만 해당 수를 표현하는 방식은 존재한다.**  
컴퓨터에선 모든 수를 **이진수로 저장**하지만, 사람이 이해하기 쉽게 하기 위해 **최상위 비트(MSB)를 1로 둠**으로서 **음수를 표현**하고자 정의했으며,   
그렇기에 **빼기에 대한 연산은 2의 보수를 활용한 덧셈**을 통해 값을 구하게 된다.

2의 보수는 **특정 값을 1의 보수로 비트 반전을 해준 값에 1을 더해줌**으로서 구할 수 있다.

**예로 25 - 10 에 대한 연산을 해보자.**  

**25에 대한 이진수는 0001 1001 이며, 10을 부호 없는 이진수로 표현하면 0000 1010이다.  
10에 대한 이진수를 1의 보수로 반전시킨 뒤, 1을 더해주겠다.**

**1111 0101  
0000 0001   (+  
ㅡㅡㅡㅡㅡㅡ  
1111 0110**

**위의 해당 값이 -10에 대한 2의 보수이다.  
그럼 이 값과 25를 더해보자.**

**0001 1001  
1111 0110   (+  
ㅡㅡㅡㅡㅡㅡ  
1 0000 1111**

**새로 구해진 최상위 비트를 버리고, 나머지 값을 10진수로 변환하면 15라는 값이 나오게 된다.**


**그럼 16진수 값을 음수로 표현하는 방법에 대한 예를 들어보자.  
0xc7이란 16진수를 signed char 타입으로 변환했을 때의 값을 알고 싶다고 했을 때  
우선 0xc7을 이진수로 변환해보면 1100 0111 이란 값이 나오게 된다.**

**이를 1의 보수로 비트 반전 시켜준 뒤, 1을 더해주면 된다.**

**0011 1000  
0000 0001  (+  
ㅡㅡㅡㅡㅡㅡ  
0011 1001**  


**그럼 57이라는 값이 나오게 되는데, 0xc7의 이진수를 봤을 때 음수라는 걸 알 수 있었으니 음수 부호를 붙여 -57이 정답이 된다.**


# 6. sizeof 연산자
sizeof 연산자는 **런타임**이 아닌 **컴파일 시간**에 **'치환'** 되기에 **걱정 없이** 사용해도 된다. 

# 7. 전위 증감 연산자와 후위 증감 연산자에 대한 차이
**일반적인 타입**에선 **후위 증감 연산자**가 **전위 증감 연산자**보다 **더 느리다**.  
**후위 증감 연산자**는 **변수의 사본을 저장하는 과정**이 필요하지만, **전위 증감 연산자는 변수의 사본을 따로 저장할 필요가 없기 때문**이다.  

**객체에서 연산자 오버로딩 사용 시**, **다른 결과**를 보여줄 수 있으므로 기억할 것.

# 8. 삼항 연산자의 진실
**최적화 컴파일**을 하지 않은 상태에서 **삼항 연산자는 if문보다 느린 속도**를 보인다.  
**컴파일러가 임시 변수**를 만들기 때문. 예로 최적화 컴파일을 끈 상태의 어셈블리를 보여주도록 하겠다.

![image](https://github.com/user-attachments/assets/9a6f336c-72b5-4e86-92b7-f8c03b2bb9db)  
위 예에서 [ebp-8]은 우리가 선언한 변수가 아닌, 컴파일러가 임의로 할당한 메모리 공간이다.

**즉, 아래 코드는**  
 
	int a = 0;

	a =  a == 0 ? a + 1 : a + 30;

**아래 코드와 같은 의미이다.**

	int a = 0;
	int b = 0;
 
	if (a == 0)
		b = a + 1;
	else
		b = a + 30;

	a = b;
 

# 9. 비트 마스킹
**비트 연산을 통해 트래픽 감소 및 로직의 간소화가 가능해진다.**  
가령 아래와 같이 8개의 on, off가 가능한 변수가 있다고 해보자. 그럼 일반적으로 bool 타입 변수 8개를 선언하여 작성할 것이다.

![image](https://github.com/user-attachments/assets/605f3b13-c4d5-48e1-85fe-4b410f1ceb58)

해당 로직을 변수 하나에 비트 하나씩 사용하여 조금 간소화 해보면 어떨까?

![image](https://github.com/user-attachments/assets/d929e407-cbe1-4bef-b9c4-a769d10e8875)

해당 코드는 char형 변수에 1바이트씩을 사용하여 설정값을 on, off 할 수 있게 작성된 코드이다. 어떤가 조금 더 보기 좋지 않은가?  


또한 **암호화**에 사용되는 **xor 비트 연산**이 존재하는데, 이는 **특이한 규칙**을 가지고 있다.  
**a와 b를 xor 연산 후 나온 값을 다시 a와 xor 연산 해주면 b의 값이 나온다는 것이다. 물론 반대도 가능하다.**


# 10. 연산자 우선 순위

![image](https://github.com/user-attachments/assets/94fca4c3-9ff6-41ec-a692-ce650d56e558)

# 11. Switch-case 문의 비밀
**일반적**으로 **잘 짜여진 switch-case문**의 경우 **다중 if-else 구문**보다 **더 빠른 속도**를 보여줄 수 있다.
이유는 **어셈블리단**에서 **cmp(비교)를 하는 것이 아닌, 메모리에 점프 테이블을 만들어 코드 구문을 뛰어 넘어 다니는 구조**이기 때문인데,   
말로서는 설명이 어려우니 직접 예시를 보도록 하자.

![image](https://github.com/user-attachments/assets/677a13a3-9fc2-4ca2-a4b0-5c076ed941c7)

해당 switch-case문의 어셈블리 코드를 보도록 하겠다.

![image](https://github.com/user-attachments/assets/43976cde-a809-48ae-96c4-145b2cf9c174)

어셈블리 코드를 보면 **우리가 일반적으로 생각하는 방식**과는 매우 많이 **다른 방식**으로 **작동**하는 것을 볼 수 있다.  
**컴파일러**마다 다르지만, **case의 개수가 n개 이상일 경우 위와 같이 점프 테이블**을 만들어 주는데,  
현재 사용중인 **ms2022 컴파일러**에선 **case문이 3개 이상**일 경우, 점프 테이블을 만들어준다.

그럼 일단 하나씩 분석해보자.

![image](https://github.com/user-attachments/assets/fe49237d-6f62-4eea-96bc-732741aea232)

**1. a의 값을 eax 레지스터로 옮긴다.**
**2. 레지스터 eax의 값을 [ebp-8]메모리 영역으로 옮긴다. 이때 해당 메모리 영역은 컴파일러가 임의로 할당한 공간이다.**
**3. [ebp-8]메모리 공간에 있는 값과 상수 3을 비교한다.**
**3-1. 해당 값을 비교하는 이유는 case문의 최대 값이 3이기 때문이다. 최대 값에 따라 해당 상수 값도 변한다.**
**4. 만약  [ebp-8]의 값이 3보다 클 경우 코드영역 (0x000DB1045)로 이동한다.**
**5. 아니라면 ecx 레지스터에 [ebp-8] 값을 옮겨주고,**
**6. 메모리 영역 0x000DB1045에 ecx * 4를 더한 만큼의 메모리 영역에서 값을 읽어와 해당 위치로 점프한다.**

그럼 해당 프로세스의 메모리를 직접 관찰해서 6번에서의 메모리 공간에 어떤 값이 있는지 살펴보자.

![image](https://github.com/user-attachments/assets/7a2e52eb-8e87-47b8-8b85-94c4e1021e8f)

해당 **점프 테이블의 메모리 공간**이다. **0x00DB1068부터 0x00DB1074**까지 **총 16바이트**가 사용되었으며, **각 4바이트마다 특정 값**들이 들어있다.
**해당 값과 어셈블리 코드의 명령어 메모리 주소**가 **비슷한 규격**을 가진 걸 알아챌 수 있는데, **정답이다.**  
**해당 메모리 공간 안에는 특정 명령어 메모리 주소(위치)가 저장되어 있고,**

![image](https://github.com/user-attachments/assets/56b73b1d-7475-46ec-bd0b-a7969f675ea3)

**해당 명령어를 통해 해당 주소로 뛰어넘어갈 수 있게 되는 것이다.**

그럼 예시를 들어보자. 
**해당 코드에서 a의 값이 2라고 가정하자.**  
**그럼 점프할 위치는 (2 * 4) + 0DB1068이다.**  
그럼 해당 메모리 위치의 값을 읽어보자.

**35 10 db 00이다.**  
보통 **역순**으로 읽어야 하므로, 
**00DB1035가 될 것이다.** 그럼 해당 메모리 위치로 이동해보자.

![image](https://github.com/user-attachments/assets/030baa52-4719-4bad-86cb-73b9c8b607cd)

**16진수 값을 대입하는데, 10진수로는 30이다.**


**그럼 만약 값이 순차적으로 증가하지 않고, 순서도 엉망이면 해당 코드를 어떻게 짜줄까?**

![image](https://github.com/user-attachments/assets/77c111af-a9c6-4792-bd85-2e27f236750b)

![image](https://github.com/user-attachments/assets/4f2ec689-7da8-439c-b788-6d3c28996f85)

**일반적인 if-else 문과 동일한 어셈블리 코드가 나오게 된다.**  
**그러면, 값이 순차적으로 증가하지만, 중간에 빼먹는 값이 존재한다면 어떨까?**

![image](https://github.com/user-attachments/assets/fbee0dd4-dc9e-4c06-8c0e-95ddcbd4d1e6)

![image](https://github.com/user-attachments/assets/fcdbb3c1-20e8-409f-980c-e6c473b697ab)

**어셈블리 코드**가 **조금 달라졌다**는 걸 눈치챌 수 있을 것이다.  
**중간에 빼먹는 값이 생기기 때문에**, **기존 방식의 점프 테이블은 만들지 못하고,** 
**또 다른 1바이트짜리 인덱스 테이블을 만들주는 과정 때문에 코드가 살짝 수정된 것이다.**

![image](https://github.com/user-attachments/assets/b94e7676-d0c3-42cf-b034-42cbf84ad6fa)

신경 쓰이는 건 해당 부분인데, 보면 **byte ptr** 즉, **0x000FE10B4 메모리 위치에서 1바이트짜리 값을 가져오라는 뜻**이다.  
그럼 해당 메모리를 직접 살펴보자.

![image](https://github.com/user-attachments/assets/cce4632e-425f-4f94-8ddb-2502d6ca1d2a)

**보면 대부분 7이라는 값이 도배되어 있고 중간중간 0부터 6까지의 값으로 채워져 있는 걸 볼 수 있다.**  
**총 23줄 90바이트 이상의 공간을 사용하고 있는데, 각 1바이트마다 점프 테이블의 인덱스값을 가진 배열인 것이다.**

그렇기 때문에 **맨 처음 1바이트엔 0이**, **다음 10바이트엔 1이 다음 20바이트엔 2가 채워져 있는 것**이다.  
**그럼 해당 값을 가져온 다음은 어떻게 진행될까?**

![image](https://github.com/user-attachments/assets/72f7af82-5ec1-4a30-8581-be5aa3e7edf9)

이건 기존 코드와 같다.  
**이전에 얻어온 인덱스 위치에 4를 곱하고 메모리 연산을 하면 점프테이블을 얻을 수 있게 된다.**

![image](https://github.com/user-attachments/assets/7dc441ec-5cf2-4555-91bc-a9068b61ab0b)

이제 조금 감이 잡히지 않는가?  
**중간중간 비어있는 값까지 점프테이블**로 만들게 된다면, **너무 많은 메모리 공간이 낭비가 되기에**  
**1바이트짜리 인덱스 테이블**을 만들어, **해당 테이블의 값을 토대로 점프 테이블에 접근 할 수 있게끔 설계**된 것이다.

참으로 효율적이지 않은가?

**결론은 switch-case문을 사용할 경우 모든 case의 값이 순차적으로 증가할 것,**  
**그리고 중간에 빼먹는 값이 최대한 없도록 하는 것이 성능적으로 좋다.**


# 12. 무한 반복문

우리가 일반적으로 사용하는 무한 반복문으론 for문과 while문이 있을 것이다.  
보통 while문을 많이 사용하지만, 성능적인 부분으로는 for 무한 반복문이 더 효율적이다.  
왜일까? 아래의 어셈블리 코드를 보자.

![image](https://github.com/user-attachments/assets/9d846593-bb30-49ba-b690-34b23a9d5016)

보면 **for 무한 반복문**은 **조건 검사 없이** jmp 명령어를 사용하고 있고,  
**while 무한 반복문**은 **매 반복**마다 **조건식의 값이 0이 아닌지를 판별**해야한다. 

**미세한 차이겠지만 성능 차이**가 있으며, **몇 만번의 반복문**을 돌릴 때 **의미**가 있는 **성능 차이**이다.  
사용할 일이 있을 수 있으니 기억해두는 게 좋을 것이다.


# 13. do-while문의 사용처
do-while문은 일반적으로 잘 사용되지 않는다. 하지만 몇몇 상황에서는 아주 유용한데 그 상황을 알아보도록 하자.

일단 **매크로 함수에서 자주 사용된다.**

![image](https://github.com/user-attachments/assets/4bdda9a5-c4c1-4e8e-b53f-ac723611d77f)

**매크로 함수는 함수와 동일한 규격**을 가져야하기 때문에 **세미클론이 필수적으로 붙어야 한다는 관행**이 존재한다.  
하지만 그럴경우, 위의 상황에서 에러가 나오게 된다.   
**매크로 함수 호출 이후의 세미클론의 위치가 if문에 붙기에 해당 절에서 if문이 끝나버리기 때문.**  
해당 문제를 해결하기 위해 do-while문을 사용해보자.

![image](https://github.com/user-attachments/assets/b3e49f45-951c-4835-93eb-7d48fa5c8dd5)

문제 해결이다.
**그냥 매크로 함수를 쓴다 == do-while로 감싸준다 라고 생각하자.**  
**MS에서 제공해주는 매크로 함수는 대부분 do-while문을 사용하고 있다.**


두 번째로는 **한 함수 내부에서 여러 if문을 사용할 경우이다.**  
아래의 예시를 보자.

![image](https://github.com/user-attachments/assets/b0807efa-44fb-4700-b750-6d736122f306)

서버에서는 위와 같은 코드가 자주 나올 수 있는데,   
해당 코드의 **문제점**으로는 **초기화 작업 코드가 여러번, 즉 중복**된다는 것이다.
이걸 해결하기 위해 do-while문을 사용할 수 있다.

![image](https://github.com/user-attachments/assets/3e280c29-2ae4-44fe-8b68-e65fbe61f207)

깔끔하다.



