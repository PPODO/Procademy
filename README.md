## 프로카데미 내용 정리

### 1. 어셈블리
   - [1. 레지스터](#-어셈블리-레지스터)
   - [2. 릴리즈와 디버그 모드](#-릴리즈와-디버그-모드)
   - [3. 명령어 체계](#-명령어-체계)
   - [4. 64비트 데이터 모델](#-64비트-데이터-모델)
   - [5. 컴퓨터의 음수 표현](#-컴퓨터의-음수-표현)




---
# 1. 어셈블리 레지스터
기억해야할 중요 명령어로는 **ESP, EBP, EIP** 레지스터가 존재한다.

컴파일 환경이 **32비트**냐 **64비트냐**에 따라 **레지스터의 이름**이 바뀌며, 

64비트 환경에서는 **RSP, RBP, RIP**로 이름이 바뀐다.

**상위 버전**의 비트는 **하위 버전**을 **호환**해야하므로 **동일한 메모리 공간**에서 **사용하는 영역**만 다르게 하는 방식으로 **호환성을 유지**한다.


**ESP** 는 Stack Pointer 로 현재 스택 프레임의 최상단 메모리 위치를 가르킨다.

**EBP**는 Base Pointer로 현재 스택 프레임의 베이스(시작 위치)를 가르킨다.

**EIP**는 현재 실행중인 코드의 위치를 가르키는 포인터이다.

**32비트**에서는 **ESP와** **EBP를** 활용하여 **스택의 메모리 할당과 해제** 에 대한 **작업**을 진행한다.

**스택의 할당과 해제**는 **함수 단위**로 이루어지는데, 여기서 말하는 함수 단위란 **함수 내부**에서 사용되는 **지역변수의 총합 크기**를 의미한다.

즉 **A라는 함수 안**에서 **int 형 변수 2개를 사용한다면 해당 함수의 단위는 8바이트**가 되는 것이다.

다시 예로 해당 함수를 호출하게 되면, **우선 EBP를 스택에 Push**하게 된다.

이유는 **이전의 함수 위치로 돌아가기 위함**이다.

그 후, **ESP를 EBP의 위치**까지 올려준 다음, **함수의 크기만큼 sub 해준다,** 그러면 **해당 함수의 크기만큼의 스택 메모리를 할당**받게 된다.

**해제**를 위해선 **ESP를 다시 EBP 위치**로 옮긴 후, **EBP를 POP**해주면 **이전 함수의 위치로 돌아갈 수 있게 된다.**

# 2. 릴리즈와 디버그 모드
보통 **릴리즈 모드**는 **디버그**가 **안 된다**라는 생각을 가지기 마련인데, **이는 사실이 아니다.**

**릴리즈 모드**에서 **브레이크 포인트**나 **조사식**이 정상적으로 작동하지 않는 이유는 **최적화 컴파일 때문**이며, 이를 끌 경우 정상적으로 작동한다.

최적화 컴파일을 통해 **내가 작성한 코드가 컴파일러에 의해 수정**되기 때문에, **작성한 코드와 1:1 매치**가 되지 않고, 이 때문에 **정상적인 디버깅이 불가능** 했을 뿐이다.


또한 디버그 모드와 릴리즈 모드의 차이점으로는 **안전 장치 유무**이다.

**디버그 모드**에서는 **각 변수마다 앞 뒤로 4바이트의 공백 공간**이 존재한다. **해당 공간은 변수의 메모리를 침범했는지를 확인**하기 위해 사용되며,

**검증 메커니즘**으로는 **모든 변수**를 **0xcc로 초기화**를 하고, **해당 공간의 값이 0xcc가 아닌 값으로 판별**되었을 때, **에러**를 내보내게 된다.

물론 **릴리즈 모드**에서는 **해당 과정이 다 빠지게 된다.**

하지만 **릴리즈 모드**에서도 **최소한의 검증 메커니즘**이 존재하는데 바로 **시크릿 쿠키**이다

함수 내에서 **지역 변수를 참조하는 포인터를 사용할 시 자동으로 추가되는 안전장치**인데, 

**4바이트의 추가 공간**을 사용하며, **특정 값의 xor 연산**들을 통해 **해당 공간이 변조**되었는지 **확인**하는 **메커니즘**이다.

**같은 값은 두 번 xor** 할 경우 **원래의 값**이 나오기 때문에 가능한 메커니즘이며 이를 **시크릿 쿠키**라 부른다.


# 3. 명령어 체계
명령어 체계로는 **CISC와 RISC**가 존재한다. 우리가 **일반적**으로 사용하는 시스템은 **CISC 명령어 체계**를 따르고 있으며, 두 명령어 체계의 **차이**는 아래와 같다.

## CISC
**복합적 명령어 체계**. **가변적인 명령어 길이(1 ~ 16바이트)**

CISC는 **명령어 단위가 바이트 단위로 깔끔하게 나뉜다**.

우리가 일반적으로 사용하는 시스템에서 **채택한 명령어 방식**이며, 그에 대한 확인 방식은 디버깅을 통해 확인할 수 있다.

디버깅을 역순으로 진행하면 명령어의 해석이 달라지는 걸 볼 수 있을 것이다.

이는 바이트 코드를 단순히 잘못 해석하기 때문이며, 읽어오는 과정에서 우선적으로 해석되는 명령어가 존재한다면, 실제론 해당 명령어가 아니더라도 해당 명령어를 사용한 것으로 추론하기 때문에 크게 신경 쓸 문제는 아니다.

## RISC
동일한 크기의 명렁어 크기

**기계어가 단순하며 가볍다**. 주로 **아두이노**에서 사용되는 명령어 체계이다.

# 4. 64비트 데이터 모델
**64비트 데이터 모델**에 따른 **자료형의 크기**가 달라진다.
데이터 모델은 다음과 같다.
| 데이터 모델 | short | int | long | long long | pointer |
| --- | --- | --- | --- | --- | --- |
| LP64 | 16 | 32 | 64 | 64 | 64 |
| ILP64 | 16 | 64 | 64 | 64 | 64 |
| SILP64 | 64 | 64 | 64 | 64 | 64 |
| LLP64 | 16 | 32 | 32 | 64 | 64 |

우리가 **일반적으로 사용하는 시스템**은 *LLP64 데이터 모델*을 사용하고 있으며, 
**리눅스 운영체제**에서는 **LP64 데이터 모델**을 사용하고 있다.

# 4. C 기억 클래스 및 속성 수식자

## 기억 클래스
1. auto : **함수 내부에서만 선언**되어, **함수 내에서만 영향을 끼치는 변수**(**스택에 할당**). 일반적인 변수 선언시 **auto 키워드는 생략**된다.
2. extern : **전역 변수를 외부 파일**에서도 사용할 수 있게끔 해주는 키워드
3. register : **CPU의 레지스터에 변수를 직접 할당할 수 있도록 기대하는 키워드**. 일반적으로 그렇게 될 **가능성은 낮기**에 사용 빈도 또한 낮다.
4. static : **정적 변수 선언**. 지역 정적 변수와 전역 정적 변수가 존재.  
    **지역 정적 변수는 함수 내 데이터 영역에 존재하며, 해당 함수 내부에서만 접근 가능하다.**  
    **전역 정적 변수는 파일 내 데이터 영역에 존재하며, 해당 파일에서만 접근 가능한 전역 변수가 된다.**

## 속성 수식자
1. volatile : **최적화 컴파일을 하지 않기 위해 사용되는 키워드**. 프로젝트의 최적화 컴파일을 끄게 된다면 불필요한 키워드가 된다.  
**CPU의 캐시 메모리 없이 물리 메모리에 접근한다는 말 또한 있지만 이는 잘못된 얘기이며, 최적화 컴파일 여부에 대한 내용만 기억하면 된다.**


# 5. 컴퓨터의 음수 표현
**기본적으로 컴퓨터에는 음수라는 개념이 존재하지 않지만 해당 수를 표현하는 방식은 존재한다.**  
컴퓨터에선 모든 수를 **이진수로 저장**하지만, 사람이 이해하기 쉽게 하기 위해 **최상위 비트(MSB)를 1로 둠**으로서 **음수를 표현**하고자 정의했으며,   
그렇기에 **빼기에 대한 연산은 2의 보수를 활용한 덧셈**을 통해 값을 구하게 된다.

2의 보수는 **특정 값을 1의 보수로 비트 반전을 해준 값에 1을 더해줌**으로서 구할 수 있다.

**예로 25 - 10 에 대한 연산을 해보자.**  

**25에 대한 이진수는 0001 1001 이며, 10을 부호 없는 이진수로 표현하면 0000 1010이다.  
10에 대한 이진수를 1의 보수로 반전시킨 뒤, 1을 더해주겠다.**

**1111 0101  
0000 0001   (+  
ㅡㅡㅡㅡㅡㅡ  
1111 0110**

**위의 해당 값이 -10에 대한 2의 보수이다.  
그럼 이 값과 25를 더해보자.**

**0001 1001  
1111 0110   (+  
ㅡㅡㅡㅡㅡㅡ  
1 0000 1111**

**새로 구해진 최상위 비트를 버리고, 나머지 값을 10진수로 변환하면 15라는 값이 나오게 된다.**


**그럼 16진수 값을 음수로 표현하는 방법에 대한 예를 들어보자.  
0xc7이란 16진수를 signed char 타입으로 변환했을 때의 값을 알고 싶다고 했을 때  
우선 0xc7을 이진수로 변환해보면 1100 0111 이란 값이 나오게 된다.**

**이를 1의 보수로 비트 반전 시켜준 뒤, 1을 더해주면 된다.**

**0011 1000  
0000 0001  (+  
ㅡㅡㅡㅡㅡㅡ  
0011 1001**  

**그럼 57이라는 값이 나오게 되는데, 0xc7의 이진수를 봤을 때 음수라는 걸 알 수 있었으니 음수 부호를 붙여 -57이 정답이 된다.**
